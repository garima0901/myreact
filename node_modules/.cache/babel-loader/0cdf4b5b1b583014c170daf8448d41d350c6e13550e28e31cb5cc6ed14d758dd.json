{"ast":null,"code":"import { pathToRegexp, match } from \"path-to-regexp\";\nimport { render, html, hydro, $, $$, setReuseElements } from \"hydro-js\";\nlet router;\nconst storageKey = \"router-scroll\";\nconst outletSelector = \"[data-outlet]\";\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst fetchCache = new WeakMap();\nlet base = $(\"base\")?.getAttribute(\"href\") || \"\";\nif (base.endsWith(\"/\")) {\n  base = [...base].slice(0, -1).join(\"\");\n}\naddEventListener(\"popstate\", async e => {\n  //@ts-expect-error\n  router.doRouting(location.pathname + location.search, e);\n});\n// Reload -> store scrollPosition\naddEventListener(\"beforeunload\", () => sessionStorage.setItem(storageKey, `${scrollX} ${scrollY}`));\nexport default class Router {\n  options;\n  routes;\n  oldRoute;\n  constructor(routes, options = {}) {\n    // Handle nested routes\n    const length = routes.length - 1;\n    for (let i = length; i >= 0; i--) {\n      const route = routes[i];\n      if (route.children) {\n        route.children.forEach((child, idx) => {\n          routes.splice(i + idx, 0, {\n            ...child,\n            path: `${route.path}/${child.path}`,\n            isChildOf: route\n          });\n        });\n        Reflect.deleteProperty(route, \"children\");\n      }\n    }\n    const newRoutes = routes.map(route => {\n      return {\n        ...route,\n        path: pathToRegexp(base + route.path),\n        originalPath: base + route.path\n      };\n    });\n    this.routes = newRoutes;\n    this.options = options;\n    router = this;\n    // Prefetch resources\n    this.routes.forEach(route => {\n      //@ts-expect-error\n      if (route.templateUrl && !navigator.connection?.saveData) {\n        const controller = new AbortController();\n        const cache = {\n          promise: null,\n          controller\n        };\n        fetchCache.set(route, cache);\n        setTimeout(() => {\n          requestIdleCallback(() => {\n            cache.promise = fetch(route.templateUrl, {\n              signal: controller.signal\n            });\n            cache.promise.then(res => res.text()).then(_html => {\n              cache.html = _html;\n            }).catch(async err => {\n              await this.options.errorHandler?.(err);\n            });\n          });\n        });\n      }\n    });\n    this.doRouting();\n  }\n  getMatchingRoute(path) {\n    if (path.startsWith(\".\")) {\n      path = path.replace(\".\", \"\");\n    }\n    return this.routes.find(route => route.path.exec(path));\n  }\n  async doRouting(to = location.pathname + location.search, e) {\n    dispatchEvent(new Event(\"beforeRouting\"));\n    const from = this.oldRoute ?? to;\n    const route = this.getMatchingRoute(to);\n    if (route) {\n      try {\n        const {\n          params\n        } = match(route.originalPath, {\n          decode: decodeURIComponent\n        })(to);\n        const allParams = {\n          ...Router.getParams(),\n          ...Object.fromEntries(Object.entries(params).map(pair => Number.isNaN(Number(pair[0])) && pair).filter(Boolean))\n        };\n        const props = {\n          from: from.replace(base, \"\"),\n          to: to.replace(base, \"\"),\n          ...(Object.keys(allParams).length ? {\n            params: allParams\n          } : {}),\n          ...(history.state && Object.keys(history.state).length ? {\n            state: history.state\n          } : {})\n        };\n        // Reset Scroll, just like Browser\n        scrollTo({\n          top: 0,\n          left: 0,\n          behavior: this.options.scrollBehavior || \"auto\"\n        });\n        // Trigger leave\n        if (this.oldRoute) {\n          const oldRoute = this.routes.find(route => route.path.exec(this.oldRoute));\n          if (oldRoute) {\n            await oldRoute[\"leave\" /* cycles.leave */]?.(props);\n            this.oldRoute = route.originalPath;\n          }\n        }\n        // Trigger beforeEnter\n        await route[\"beforeEnter\" /* cycles.beforeEnter */]?.(props);\n        // Handle template / element\n        if (!!route.isChildOf) {\n          setReuseElements(false);\n          const parent = route.isChildOf;\n          if (parent.templateUrl) {\n            await handleTemplate(parent, $(outletSelector));\n          } else if (parent.element) {\n            const copy = $(outletSelector).cloneNode();\n            copy.append(html`${parent.element}`);\n            render(copy, outletSelector, false);\n          }\n          setReuseElements(true);\n        }\n        if (route?.templateUrl) {\n          await handleTemplate(route, $(outletSelector).querySelector(outletSelector) ?? $(outletSelector));\n        } else if (route?.element) {\n          const where = $(outletSelector).querySelector(outletSelector) ?? $(outletSelector);\n          const copy = where.cloneNode();\n          copy.append(html`${route.element}`);\n          render(copy, where, false);\n        } else {\n          // Clear outlet\n          $(outletSelector).textContent = null;\n        }\n        // Trigger afterEnter\n        await route[\"afterEnter\" /* cycles.afterEnter */]?.(props);\n      } catch (err) {\n        if (this.options.errorHandler) {\n          await this.options.errorHandler(err, e);\n        } else {\n          console.error(err, e);\n        }\n      } finally {\n        dispatchEvent(new Event(\"afterRouting\"));\n        // Reload -> restore scroll position\n        if (!this.oldRoute && route.restoreScrollOnReload && sessionStorage.getItem(storageKey)) {\n          const [left, top] = sessionStorage.getItem(storageKey).split(\" \").map(Number);\n          sessionStorage.removeItem(storageKey);\n          scrollTo({\n            top,\n            left,\n            behavior: this.options.scrollBehavior || \"auto\"\n          });\n        }\n      }\n    }\n  }\n  go(path, state, params = \"\") {\n    this.oldRoute = location.pathname + location.search;\n    const newPath = base + path + params;\n    // Only navigate when the path differs\n    if (newPath !== this.oldRoute) {\n      history.pushState({\n        ...state\n      }, \"\", newPath);\n      this.doRouting(newPath);\n    }\n  }\n  removeRoute(path) {\n    const idx = this.routes.findIndex(route => String(route.path) === String(pathToRegexp(path)));\n    if (idx > -1) {\n      this.routes.splice(idx, 1);\n    }\n  }\n  addRoute(route) {\n    this.routes.push({\n      ...route,\n      path: pathToRegexp(base + route.path),\n      originalPath: base + route.path\n    });\n  }\n  modifyRoute(path, newRoute) {\n    const idx = this.routes.findIndex(route => String(route.path) === String(pathToRegexp(path)));\n    if (idx > -1) {\n      this.routes[idx] = {\n        ...newRoute,\n        path: pathToRegexp(base + newRoute.path),\n        originalPath: base + path\n      };\n    }\n  }\n  changeOptions(options) {\n    this.options = options;\n  }\n  static getParams(search = location.search) {\n    return Object.fromEntries(new URLSearchParams(search));\n  }\n}\nfunction registerAnchorEvent(anchor) {\n  if (anchor.getAttribute(\"href\")?.startsWith(\"http\")) return;\n  anchor.addEventListener(\"click\", e => {\n    e.preventDefault();\n    const hasData = anchor.getAttribute(\"data\");\n    const hydroProp = replaceBars(hasData);\n    const href = anchor.getAttribute(\"href\") || \"\";\n    router.go(href, hasData ? hydro[hydroProp] : void 0);\n  });\n}\nfunction registerFormEvent(form) {\n  form.addEventListener(\"submit\", e => {\n    if (!router.options.formHandler) return;\n    e.preventDefault();\n    const action = form.getAttribute(\"action\");\n    const method = form.getAttribute(\"method\");\n    fetch(action, {\n      method,\n      ...(![\"HEAD\", \"GET\"].includes(method.toUpperCase()) ? {\n        body: new FormData(form)\n      } : {})\n    }).then(res => router.options.formHandler(res, e)).catch(async err => {\n      if (router.options.errorHandler) {\n        await router.options.errorHandler(err, e);\n      } else {\n        console.error(err, e);\n      }\n    });\n  });\n}\nfunction replaceBars(hydroTerm) {\n  if (hydroTerm === null || !hydroTerm.includes(\"{{\")) return hydroTerm;\n  const [_, hydroPath] = hydroTerm.match(reactivityRegex) || [];\n  return hydroPath;\n}\n// Add EventListener for every added anchor and form Element\n$$(\"a\").forEach(registerAnchorEvent);\n$$(\"form\").forEach(registerFormEvent);\nnew MutationObserver(entries => {\n  for (const entry of entries) {\n    for (const node of entry.addedNodes) {\n      const nodes = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, {\n        acceptNode(elem) {\n          return [\"form\", \"a\"].includes(elem.localName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n        }\n      });\n      let formOrA;\n      while (formOrA = nodes.nextNode()) {\n        if (formOrA.localName === \"a\") {\n          registerAnchorEvent(formOrA);\n        } else {\n          registerFormEvent(formOrA);\n        }\n      }\n    }\n  }\n}).observe(document.body, {\n  childList: true,\n  subtree: true\n});\nasync function handleTemplate(route, where) {\n  let cacheObj = fetchCache.get(route);\n  if (!fetchCache.has(route) || cacheObj?.promise === null) {\n    cacheObj.controller?.abort();\n    const data = await fetch(route.templateUrl);\n    if (!cacheObj) {\n      cacheObj = {\n        html: await data.text()\n      };\n      fetchCache.set(route, cacheObj);\n    } else {\n      cacheObj.html = await data.text();\n    }\n  }\n  Reflect.deleteProperty(cacheObj, \"controller\");\n  const copy = where.cloneNode();\n  copy.append(window.isHMR ? html`${await (await fetch(route.templateUrl)).text()}` : html`${(await cacheObj.html) || \"\"}`);\n  render(copy, where, false);\n}","map":{"version":3,"names":["pathToRegexp","match","render","html","hydro","$","$$","setReuseElements","router","storageKey","outletSelector","reactivityRegex","fetchCache","WeakMap","base","getAttribute","endsWith","slice","join","addEventListener","e","doRouting","location","pathname","search","sessionStorage","setItem","scrollX","scrollY","Router","options","routes","oldRoute","constructor","length","i","route","children","forEach","child","idx","splice","path","isChildOf","Reflect","deleteProperty","newRoutes","map","originalPath","templateUrl","navigator","connection","saveData","controller","AbortController","cache","promise","set","setTimeout","requestIdleCallback","fetch","signal","then","res","text","_html","catch","err","errorHandler","getMatchingRoute","startsWith","replace","find","exec","to","dispatchEvent","Event","from","params","decode","decodeURIComponent","allParams","getParams","Object","fromEntries","entries","pair","Number","isNaN","filter","Boolean","props","keys","history","state","scrollTo","top","left","behavior","scrollBehavior","parent","handleTemplate","element","copy","cloneNode","append","querySelector","where","textContent","console","error","restoreScrollOnReload","getItem","split","removeItem","go","newPath","pushState","removeRoute","findIndex","String","addRoute","push","modifyRoute","newRoute","changeOptions","URLSearchParams","registerAnchorEvent","anchor","preventDefault","hasData","hydroProp","replaceBars","href","registerFormEvent","form","formHandler","action","method","includes","toUpperCase","body","FormData","hydroTerm","_","hydroPath","MutationObserver","entry","node","addedNodes","nodes","document","createNodeIterator","NodeFilter","SHOW_ELEMENT","acceptNode","elem","localName","FILTER_ACCEPT","FILTER_REJECT","formOrA","nextNode","observe","childList","subtree","cacheObj","get","has","abort","data","window","isHMR"],"sources":["C:/Users/Garima/OneDrive/Desktop/iiim/node_modules/router-dom/dist/router.js"],"sourcesContent":["import { pathToRegexp, match } from \"path-to-regexp\";\nimport { render, html, hydro, $, $$, setReuseElements } from \"hydro-js\";\nlet router;\nconst storageKey = \"router-scroll\";\nconst outletSelector = \"[data-outlet]\";\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst fetchCache = new WeakMap();\nlet base = $(\"base\")?.getAttribute(\"href\") || \"\";\nif (base.endsWith(\"/\")) {\n    base = [...base].slice(0, -1).join(\"\");\n}\naddEventListener(\"popstate\", async (e) => {\n    //@ts-expect-error\n    router.doRouting(location.pathname + location.search, e);\n});\n// Reload -> store scrollPosition\naddEventListener(\"beforeunload\", () => sessionStorage.setItem(storageKey, `${scrollX} ${scrollY}`));\nexport default class Router {\n    options;\n    routes;\n    oldRoute;\n    constructor(routes, options = {}) {\n        // Handle nested routes\n        const length = routes.length - 1;\n        for (let i = length; i >= 0; i--) {\n            const route = routes[i];\n            if (route.children) {\n                route.children.forEach((child, idx) => {\n                    routes.splice(i + idx, 0, {\n                        ...child,\n                        path: `${route.path}/${child.path}`,\n                        isChildOf: route,\n                    });\n                });\n                Reflect.deleteProperty(route, \"children\");\n            }\n        }\n        const newRoutes = routes.map((route) => {\n            return {\n                ...route,\n                path: pathToRegexp(base + route.path),\n                originalPath: base + route.path,\n            };\n        });\n        this.routes = newRoutes;\n        this.options = options;\n        router = this;\n        // Prefetch resources\n        this.routes.forEach((route) => {\n            //@ts-expect-error\n            if (route.templateUrl && !navigator.connection?.saveData) {\n                const controller = new AbortController();\n                const cache = { promise: null, controller };\n                fetchCache.set(route, cache);\n                setTimeout(() => {\n                    requestIdleCallback(() => {\n                        cache.promise = fetch(route.templateUrl, {\n                            signal: controller.signal,\n                        });\n                        cache.promise\n                            .then((res) => res.text())\n                            .then((_html) => {\n                            cache.html = _html;\n                        })\n                            .catch(async (err) => {\n                            await this.options.errorHandler?.(err);\n                        });\n                    });\n                });\n            }\n        });\n        this.doRouting();\n    }\n    getMatchingRoute(path) {\n        if (path.startsWith(\".\")) {\n            path = path.replace(\".\", \"\");\n        }\n        return this.routes.find((route) => route.path.exec(path));\n    }\n    async doRouting(to = location.pathname + location.search, e) {\n        dispatchEvent(new Event(\"beforeRouting\"));\n        const from = this.oldRoute ?? to;\n        const route = this.getMatchingRoute(to);\n        if (route) {\n            try {\n                const { params } = match(route.originalPath, {\n                    decode: decodeURIComponent,\n                })(to);\n                const allParams = {\n                    ...Router.getParams(),\n                    ...Object.fromEntries(Object.entries(params)\n                        .map((pair) => Number.isNaN(Number(pair[0])) && pair)\n                        .filter(Boolean)),\n                };\n                const props = {\n                    from: from.replace(base, \"\"),\n                    to: to.replace(base, \"\"),\n                    ...(Object.keys(allParams).length ? { params: allParams } : {}),\n                    ...(history.state && Object.keys(history.state).length\n                        ? { state: history.state }\n                        : {}),\n                };\n                // Reset Scroll, just like Browser\n                scrollTo({\n                    top: 0,\n                    left: 0,\n                    behavior: this.options.scrollBehavior || \"auto\",\n                });\n                // Trigger leave\n                if (this.oldRoute) {\n                    const oldRoute = this.routes.find((route) => route.path.exec(this.oldRoute));\n                    if (oldRoute) {\n                        await oldRoute[\"leave\" /* cycles.leave */]?.(props);\n                        this.oldRoute = route.originalPath;\n                    }\n                }\n                // Trigger beforeEnter\n                await route[\"beforeEnter\" /* cycles.beforeEnter */]?.(props);\n                // Handle template / element\n                if (!!route.isChildOf) {\n                    setReuseElements(false);\n                    const parent = route.isChildOf;\n                    if (parent.templateUrl) {\n                        await handleTemplate(parent, $(outletSelector));\n                    }\n                    else if (parent.element) {\n                        const copy = $(outletSelector).cloneNode();\n                        copy.append(html `${parent.element}`);\n                        render(copy, outletSelector, false);\n                    }\n                    setReuseElements(true);\n                }\n                if (route?.templateUrl) {\n                    await handleTemplate(route, $(outletSelector).querySelector(outletSelector) ??\n                        $(outletSelector));\n                }\n                else if (route?.element) {\n                    const where = $(outletSelector).querySelector(outletSelector) ??\n                        $(outletSelector);\n                    const copy = where.cloneNode();\n                    copy.append(html `${route.element}`);\n                    render(copy, where, false);\n                }\n                else {\n                    // Clear outlet\n                    $(outletSelector).textContent = null;\n                }\n                // Trigger afterEnter\n                await route[\"afterEnter\" /* cycles.afterEnter */]?.(props);\n            }\n            catch (err) {\n                if (this.options.errorHandler) {\n                    await this.options.errorHandler(err, e);\n                }\n                else {\n                    console.error(err, e);\n                }\n            }\n            finally {\n                dispatchEvent(new Event(\"afterRouting\"));\n                // Reload -> restore scroll position\n                if (!this.oldRoute &&\n                    route.restoreScrollOnReload &&\n                    sessionStorage.getItem(storageKey)) {\n                    const [left, top] = sessionStorage\n                        .getItem(storageKey)\n                        .split(\" \")\n                        .map(Number);\n                    sessionStorage.removeItem(storageKey);\n                    scrollTo({\n                        top,\n                        left,\n                        behavior: this.options.scrollBehavior || \"auto\",\n                    });\n                }\n            }\n        }\n    }\n    go(path, state, params = \"\") {\n        this.oldRoute = location.pathname + location.search;\n        const newPath = base + path + params;\n        // Only navigate when the path differs\n        if (newPath !== this.oldRoute) {\n            history.pushState({ ...state }, \"\", newPath);\n            this.doRouting(newPath);\n        }\n    }\n    removeRoute(path) {\n        const idx = this.routes.findIndex((route) => String(route.path) === String(pathToRegexp(path)));\n        if (idx > -1) {\n            this.routes.splice(idx, 1);\n        }\n    }\n    addRoute(route) {\n        this.routes.push({\n            ...route,\n            path: pathToRegexp(base + route.path),\n            originalPath: base + route.path,\n        });\n    }\n    modifyRoute(path, newRoute) {\n        const idx = this.routes.findIndex((route) => String(route.path) === String(pathToRegexp(path)));\n        if (idx > -1) {\n            this.routes[idx] = {\n                ...newRoute,\n                path: pathToRegexp(base + newRoute.path),\n                originalPath: base + path,\n            };\n        }\n    }\n    changeOptions(options) {\n        this.options = options;\n    }\n    static getParams(search = location.search) {\n        return Object.fromEntries(new URLSearchParams(search));\n    }\n}\nfunction registerAnchorEvent(anchor) {\n    if (anchor.getAttribute(\"href\")?.startsWith(\"http\"))\n        return;\n    anchor.addEventListener(\"click\", (e) => {\n        e.preventDefault();\n        const hasData = anchor.getAttribute(\"data\");\n        const hydroProp = replaceBars(hasData);\n        const href = anchor.getAttribute(\"href\") || \"\";\n        router.go(href, hasData ? hydro[hydroProp] : void 0);\n    });\n}\nfunction registerFormEvent(form) {\n    form.addEventListener(\"submit\", (e) => {\n        if (!router.options.formHandler)\n            return;\n        e.preventDefault();\n        const action = form.getAttribute(\"action\");\n        const method = form.getAttribute(\"method\");\n        fetch(action, {\n            method,\n            ...(![\"HEAD\", \"GET\"].includes(method.toUpperCase())\n                ? { body: new FormData(form) }\n                : {}),\n        })\n            .then((res) => router.options.formHandler(res, e))\n            .catch(async (err) => {\n            if (router.options.errorHandler) {\n                await router.options.errorHandler(err, e);\n            }\n            else {\n                console.error(err, e);\n            }\n        });\n    });\n}\nfunction replaceBars(hydroTerm) {\n    if (hydroTerm === null || !hydroTerm.includes(\"{{\"))\n        return hydroTerm;\n    const [_, hydroPath] = hydroTerm.match(reactivityRegex) || [];\n    return hydroPath;\n}\n// Add EventListener for every added anchor and form Element\n$$(\"a\").forEach(registerAnchorEvent);\n$$(\"form\").forEach(registerFormEvent);\nnew MutationObserver((entries) => {\n    for (const entry of entries) {\n        for (const node of entry.addedNodes) {\n            const nodes = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, {\n                acceptNode(elem) {\n                    return [\"form\", \"a\"].includes(elem.localName)\n                        ? NodeFilter.FILTER_ACCEPT\n                        : NodeFilter.FILTER_REJECT;\n                },\n            });\n            let formOrA;\n            while ((formOrA = nodes.nextNode())) {\n                if (formOrA.localName === \"a\") {\n                    registerAnchorEvent(formOrA);\n                }\n                else {\n                    registerFormEvent(formOrA);\n                }\n            }\n        }\n    }\n}).observe(document.body, { childList: true, subtree: true });\nasync function handleTemplate(route, where) {\n    let cacheObj = fetchCache.get(route);\n    if (!fetchCache.has(route) || cacheObj?.promise === null) {\n        cacheObj.controller?.abort();\n        const data = await fetch(route.templateUrl);\n        if (!cacheObj) {\n            cacheObj = {\n                html: await data.text(),\n            };\n            fetchCache.set(route, cacheObj);\n        }\n        else {\n            cacheObj.html = await data.text();\n        }\n    }\n    Reflect.deleteProperty(cacheObj, \"controller\");\n    const copy = where.cloneNode();\n    copy.append(window.isHMR\n        ? html `${await (await fetch(route.templateUrl)).text()}`\n        : html `${(await cacheObj.html) || \"\"}`);\n    render(copy, where, false);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}