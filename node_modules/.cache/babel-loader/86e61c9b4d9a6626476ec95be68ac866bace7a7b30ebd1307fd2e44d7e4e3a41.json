{"ast":null,"code":"// Safari Polyfills\nwindow.requestIdleCallback = /* c8 ignore next 4 */\nwindow.requestIdleCallback || ((cb, _, start = performance.now()) => setTimeout(cb, 0, {\n  didTimeout: false,\n  timeRemaining: () => Math.max(0, 5 - (performance.now() - start))\n}));\n// Safari Polyfills END\nconst range = document.createRange();\nrange.selectNodeContents(range.createContextualFragment(`<${\"template\" /* Placeholder.template */}>`).lastChild);\nconst parser = range.createContextualFragment.bind(range);\nconst allNodeChanges = new WeakMap(); // Maps a Node against an array of changes. An array is necessary because a node can have multiple variables for one text / attribute.\nconst elemEventFunctions = new WeakMap(); // Stores event functions in order to compare Elements against each other.\nconst reactivityMap = new WeakMap(); // Maps Proxy Objects to another Map(proxy-key, node).\nconst bindMap = new WeakMap(); // Bind an Element to data. If the data is being unset, the DOM Element disappears too.\nconst tmpSwap = new WeakMap(); // Take over keyToNodeMap if the new value is a hydro Proxy. Save old reactivityMap entry here, in case for a swap operation.\nconst onRenderMap = new WeakMap(); // Lifecycle Hook that is being called after rendering\nconst onCleanupMap = new WeakMap(); // Lifecycle Hook that is being called when unmount function is being called\nconst fragmentToElements = new WeakMap(); // Used to retreive Elements from DocumentFragment after it has been rendered â€“ for diffing\nconst _boundFunctions = Symbol(\"boundFunctions\"); // Cache for bound functions in Proxy, so that we create the bound version of each function only once\nconst reactiveSymbol = Symbol(\"reactive\");\nconst keysSymbol = Symbol(\"keys\");\nlet globalSchedule = true; // Decides whether to schedule rendering and updating (async)\nlet reuseElements = true; // Reuses Elements when rendering\nlet insertBeforeDiffing = false; // Makes sense in Chrome only\nlet shouldSetReactivity = true;\nlet viewElements = false;\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst HTML_FIND_INVALID = /<(\\/?)(html|head|body)(>|\\s.*?>)/g;\nconst newLineRegex = /\\n/g;\nconst propChainRegex = /[\\.\\[\\]]/;\nconst onEventRegex = /^on/;\n// https://html.spec.whatwg.org/#attributes-3\n// if value for bool attr is falsy, then remove attr\n// INFO: draggable and spellcheck are actually using booleans as string! Also, hidden is not really a bool attr, but is making use of the empty string too. Might consider to add 'translate' (yes and no as string)\nconst boolAttrList = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"draggable\", \"default\", \"defer\", \"disabled\", \"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"itemscope\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"selected\", \"spellcheck\"];\nlet lastSwapElem = null;\nlet internReset = false;\nfunction isObject(obj) {\n  return obj != null && typeof obj === \"object\";\n}\nfunction isFunction(func) {\n  return typeof func === \"function\" /* Placeholder.function */;\n}\n\nfunction isTextNode(node) {\n  return node.splitText !== undefined;\n}\nfunction isNode(node) {\n  return node instanceof Node;\n}\nfunction isDocumentFragment(node) {\n  return node.nodeType === 11;\n}\nfunction isEventObject(obj) {\n  return isObject(obj) && \"event\" /* Placeholder.event */ in obj && \"options\" /* Placeholder.options */ in obj;\n}\nfunction isProxy(hydroObject) {\n  return Reflect.get(hydroObject, \"isProxy\" /* Placeholder.isProxy */);\n}\n\nfunction isPromise(obj) {\n  return isObject(obj) && typeof obj.then === \"function\";\n}\nfunction randomText() {\n  const randomChars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n  let result = \"\";\n  for (var i = 0; i < 6; i++) {\n    result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n  }\n  return result;\n  // return Math.random().toString(32).slice(2);\n}\n\nfunction setGlobalSchedule(willSchedule) {\n  globalSchedule = willSchedule;\n  setHydroRecursive(hydro);\n}\nfunction setReuseElements(willReuse) {\n  reuseElements = willReuse;\n}\nfunction setInsertDiffing(willInsert) {\n  insertBeforeDiffing = willInsert;\n}\nfunction setShouldSetReactivity(willSet) {\n  shouldSetReactivity = willSet;\n}\nfunction setHydroRecursive(obj) {\n  Reflect.set(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */, globalSchedule);\n  for (const value of Object.values(obj)) {\n    if (isObject(value) && isProxy(value)) {\n      setHydroRecursive(value);\n    }\n  }\n}\nfunction setAttribute(node, key, val) {\n  if (boolAttrList.includes(key) && !val) {\n    node.removeAttribute(key);\n    return false;\n  }\n  node.setAttribute(key, val);\n  return true;\n}\nfunction addEventListener(node, eventName, obj) {\n  node.addEventListener(eventName, isFunction(obj) ? obj : obj.event, isFunction(obj) ? {} : obj.options);\n}\nfunction html(htmlArray, ...variables) {\n  const eventFunctions = {}; // Temporarily store a mapping for string -> function, because eventListener have to be registered after the Element's creation\n  let insertNodes = []; // Nodes, that will be added after the parsing\n  const resolvedVariables = [];\n  for (const variable of variables) {\n    const template = `<${\"template\" /* Placeholder.template */} id=\"lbInsertNodes\"></${\"template\" /* Placeholder.template */}>`;\n    switch (variable) {\n      case isNode(variable) && variable:\n        {\n          insertNodes.push(variable);\n          resolvedVariables.push(template);\n          break;\n        }\n      case ([\"number\", \"string\" /* Placeholder.string */, \"symbol\", \"boolean\", \"bigint\"].includes(typeof variable) || Reflect.has(variable, reactiveSymbol)) && variable:\n        {\n          resolvedVariables.push(String(variable));\n          break;\n        }\n      case (isFunction(variable) || isEventObject(variable)) && variable:\n        {\n          const funcName = randomText();\n          Reflect.set(eventFunctions, funcName, variable);\n          resolvedVariables.push(funcName);\n          break;\n        }\n      case Array.isArray(variable) && variable:\n        {\n          for (let index = 0; index < variable.length; index++) {\n            const item = variable[index];\n            if (isNode(item)) {\n              insertNodes.push(item);\n              variable[index] = template;\n            }\n          }\n          resolvedVariables.push(variable.join(\"\"));\n          break;\n        }\n      case isObject(variable) && variable:\n        {\n          let result = \"\";\n          for (const [key, value] of Object.entries(variable)) {\n            if (isFunction(value) || isEventObject(value)) {\n              const funcName = randomText();\n              Reflect.set(eventFunctions, funcName, value);\n              result += `${key}=\"${funcName}\"`;\n            } else {\n              result += `${key}=\"${value}\"`;\n            }\n          }\n          resolvedVariables.push(result);\n          break;\n        }\n    }\n    /* c8 ignore next 1 */\n  }\n  // Find elements <html|head|body>, as they cannot be created by the parser. Replace them by fake Custom Elements and replace them afterwards.\n  let DOMString = String.raw(htmlArray, ...resolvedVariables).trim();\n  DOMString = DOMString.replace(HTML_FIND_INVALID, `<$1$2${\"-dummy\" /* Placeholder.dummy */}$3`);\n  const DOM = parser(DOMString);\n  // Delay Element iteration and manipulation after the elements have been added to the DOM.\n  if (!viewElements) {\n    fillDOM(DOM, insertNodes, eventFunctions);\n  }\n  // Return DocumentFragment\n  if (DOM.childNodes.length > 1) return DOM;\n  // Return empty Text Node\n  if (!DOM.firstChild) return document.createTextNode(\"\");\n  // Return Element | Text\n  return DOM.firstChild;\n}\nfunction fillDOM(elem, insertNodes, eventFunctions) {\n  const root = document.createNodeIterator(elem, NodeFilter.SHOW_ELEMENT, {\n    acceptNode(element) {\n      return element.localName.endsWith(\"-dummy\" /* Placeholder.dummy */) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n    }\n  });\n  let nextNode;\n  while (nextNode = root.nextNode()) {\n    const tag = nextNode.localName.replace(\"-dummy\" /* Placeholder.dummy */, \"\");\n    const replacement = document.createElement(tag);\n    replacement.append(...nextNode.childNodes);\n    /* c8 ignore next 3 */\n    for (const key of nextNode.getAttributeNames()) {\n      replacement.setAttribute(key, nextNode.getAttribute(key));\n    }\n    nextNode.replaceWith(replacement);\n  }\n  // Insert HTML Elements, which were stored in insertNodes\n  if (!isTextNode(elem)) {\n    for (const template of elem.querySelectorAll(\"template[id^=lbInsertNodes]\")) template.replaceWith(insertNodes.shift());\n  }\n  if (shouldSetReactivity) setReactivity(elem, eventFunctions);\n}\n/* c8 ignore start */\nfunction h(name, props, ...children) {\n  if (isFunction(name)) return name({\n    ...props,\n    children\n  });\n  const elem = document.createElement(name);\n  for (let i in props) {\n    i in elem && !boolAttrList.includes(i) ?\n    //@ts-ignore\n    elem[i] = props[i] : setAttribute(elem, i, props[i]);\n  }\n  elem.append(...(children.some(i => Array.isArray(i)) ? children.map(getChildren).flat() : children));\n  if (!viewElements) {\n    setReactivity(elem);\n  }\n  return elem;\n}\nfunction getChildren(child) {\n  return isObject(child) && !isNode(child) ? Object.values(child) : child;\n}\n/* c8 ignore end */\nfunction setReactivity(DOM, eventFunctions) {\n  if (isTextNode(DOM)) {\n    setReactivitySingle(DOM);\n    return;\n  }\n  const elems = document.createNodeIterator(DOM, NodeFilter.SHOW_ELEMENT);\n  let elem;\n  while (elem = elems.nextNode()) {\n    for (const key of elem.getAttributeNames()) {\n      // Set functions\n      const val = elem.getAttribute(key);\n      if (eventFunctions && key.startsWith(\"on\")) {\n        const eventName = key.replace(onEventRegex, \"\");\n        const event = eventFunctions[val];\n        if (!event) {\n          setReactivitySingle(elem, key, val);\n          continue;\n        }\n        elem.removeAttribute(key);\n        if (isEventObject(event)) {\n          elem.addEventListener(eventName, event.event, event.options);\n          if (elemEventFunctions.has(elem)) {\n            elemEventFunctions.get(elem).push(event.event);\n          } else {\n            elemEventFunctions.set(elem, [event.event]);\n          }\n        } else {\n          elem.addEventListener(eventName, event);\n          if (elemEventFunctions.has(elem)) {\n            elemEventFunctions.get(elem).push(event);\n          } else {\n            elemEventFunctions.set(elem, [event]);\n          }\n        }\n      } else {\n        setReactivitySingle(elem, key, val);\n      }\n    }\n    let childNode = elem.firstChild;\n    while (childNode) {\n      if (isTextNode(childNode) && childNode.nodeValue?.includes(\"{{\")) {\n        setReactivitySingle(childNode);\n      }\n      childNode = childNode.nextSibling;\n    }\n  }\n}\nfunction setReactivitySingle(node, key, val) {\n  let attr_OR_text, match;\n  if (!key) {\n    attr_OR_text = node.nodeValue; // nodeValue is (always) defined on Text Nodes\n  } else {\n    attr_OR_text = val;\n    if (attr_OR_text === \"\") {\n      // e.g. checked attribute or two-way attribute\n      attr_OR_text = key;\n      if (attr_OR_text.startsWith(\"{{\")) {\n        node.removeAttribute(attr_OR_text);\n      }\n    }\n  }\n  while (match = attr_OR_text.match(reactivityRegex)) {\n    // attr_OR_text will be altered in every iteration\n    const [hydroMatch, hydroPath] = match;\n    const properties = hydroPath.trim().replace(newLineRegex, \"\").split(propChainRegex).filter(Boolean);\n    const [resolvedValue, resolvedObj] = resolveObject(properties);\n    let lastProp = properties[properties.length - 1];\n    const start = match.index;\n    let end = start + String(resolvedValue).length;\n    if (isNode(resolvedValue)) {\n      node.nodeValue = attr_OR_text.replace(hydroMatch, \"\");\n      node.after(resolvedValue);\n      setTraces(start, end, resolvedValue, lastProp, resolvedObj, key);\n      return;\n    }\n    // Set Text or set Attribute\n    if (isTextNode(node)) {\n      const textContent = isObject(resolvedValue) ? JSON.stringify(resolvedValue) : resolvedValue ?? \"\";\n      attr_OR_text = attr_OR_text.replace(hydroMatch, textContent);\n      if (attr_OR_text != null) {\n        node.nodeValue = attr_OR_text;\n      }\n    } else {\n      if (key === \"bind\") {\n        attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n        node.removeAttribute(key);\n        const proxy = isObject(resolvedValue) && isProxy(resolvedValue) ? resolvedValue : resolvedObj;\n        if (bindMap.has(proxy)) {\n          bindMap.get(proxy).push(node);\n        } else {\n          bindMap.set(proxy, [node]);\n        }\n        continue;\n      } else if (key === \"two-way\" /* Placeholder.twoWay */) {\n        if (node instanceof HTMLSelectElement) {\n          node.value = resolvedValue;\n          changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n        } else if (node instanceof HTMLInputElement && node.type === \"radio\" /* Placeholder.radio */) {\n          node.checked = node.value === resolvedValue;\n          changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n        } else if (node instanceof HTMLInputElement && node.type === \"checkbox\" /* Placeholder.checkbox */) {\n          node.checked = resolvedValue;\n          changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp, true);\n        } else if (node instanceof HTMLTextAreaElement || node instanceof HTMLInputElement) {\n          node.value = resolvedValue;\n          changeAttrVal(\"input\", node, resolvedObj, lastProp);\n        }\n        attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n        node.setAttribute(\"two-way\" /* Placeholder.twoWay */, \"\");\n      } else if (isFunction(resolvedValue) || isEventObject(resolvedValue)) {\n        attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n        node.removeAttribute(key);\n        addEventListener(node, key.replace(onEventRegex, \"\"), resolvedValue);\n      } else if (isObject(resolvedValue)) {\n        // Case: setting attrs on Element - <p ${props}>\n        for (const [subKey, subVal] of Object.entries(resolvedValue)) {\n          attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n          if (isFunction(subVal) || isEventObject(subVal)) {\n            addEventListener(node, subKey.replace(onEventRegex, \"\"), subVal);\n          } else {\n            lastProp = subKey;\n            if (setAttribute(node, subKey, subVal)) {\n              end = start + String(subVal).length;\n            } else {\n              end = start;\n            }\n          }\n          setTraces(start, end, node, lastProp, resolvedValue, subKey);\n        }\n        continue; // As we set all Mappings via subKeys\n      } else {\n        attr_OR_text = attr_OR_text.replace(hydroMatch, resolvedValue);\n        if (!setAttribute(node, key, attr_OR_text === String(resolvedValue) ? resolvedValue : attr_OR_text)) {\n          attr_OR_text = attr_OR_text.replace(resolvedValue, \"\");\n        }\n      }\n    }\n    setTraces(start, end, node, lastProp, resolvedObj, key);\n  }\n}\n// Same behavior as v-model in https://v3.vuejs.org/guide/forms.html#basic-usage\nfunction changeAttrVal(eventName, node, resolvedObj, lastProp, isChecked = false) {\n  node.addEventListener(eventName, changeHandler);\n  onCleanup(() => node.removeEventListener(eventName, changeHandler), node);\n  function changeHandler({\n    target\n  }) {\n    Reflect.set(resolvedObj, lastProp, isChecked ? target.checked : target.value);\n  }\n}\nfunction setTraces(start, end, node, hydroKey, resolvedObj, key) {\n  // Set WeakMaps, that will be used to track a change for a Node but also to check if a Node has any other changes.\n  const change = [start, end, key];\n  const changeArr = [change];\n  if (allNodeChanges.has(node)) {\n    allNodeChanges.get(node).push(change);\n  } else {\n    allNodeChanges.set(node, [change]); // Use own version. Otherwise changes, will lead to incorrect changes in the DOM.\n  }\n\n  if (reactivityMap.has(resolvedObj)) {\n    const keyToNodeMap = reactivityMap.get(resolvedObj);\n    const nodeToChangeMap = keyToNodeMap.get(hydroKey);\n    if (nodeToChangeMap) {\n      if (nodeToChangeMap.has(node)) {\n        nodeToChangeMap.get(node).push(change);\n      } else {\n        nodeToChangeMap.set(changeArr, node);\n        nodeToChangeMap.set(node, changeArr);\n      }\n    } else {\n      keyToNodeMap.set(hydroKey,\n      //@ts-ignore\n      new Map([[changeArr, node], [node, changeArr]]));\n    }\n  } else {\n    reactivityMap.set(resolvedObj, new Map([[hydroKey,\n    //@ts-ignore\n    new Map([[changeArr, node], [node, changeArr]])]]));\n  }\n}\n// Helper function to return a value and hydro obj from a chain of properties\nfunction resolveObject(propertyArray) {\n  let value, prev;\n  value = prev = hydro;\n  for (const prop of propertyArray) {\n    prev = value;\n    value = Reflect.get(prev, prop);\n  }\n  return [value, prev];\n}\nfunction compareEvents(elem, where, onlyTextChildren) {\n  const elemFunctions = [];\n  const whereFunctions = [];\n  if (isTextNode(elem)) {\n    if (onRenderMap.has(elem)) {\n      elemFunctions.push(onRenderMap.get(elem));\n    }\n    if (onCleanupMap.has(elem)) {\n      elemFunctions.push(onCleanupMap.get(elem));\n    }\n    if (onRenderMap.has(where)) {\n      whereFunctions.push(onRenderMap.get(where));\n    }\n    if (onCleanupMap.has(where)) {\n      whereFunctions.push(onCleanupMap.get(where));\n    }\n    if (elemFunctions.length !== whereFunctions.length) return false;\n    if (String(elemFunctions) !== String(whereFunctions)) return false;\n    return true;\n  }\n  if (elemEventFunctions.has(elem)) {\n    elemFunctions.push(...elemEventFunctions.get(elem));\n  }\n  if (elemEventFunctions.has(where)) {\n    whereFunctions.push(...elemEventFunctions.get(where));\n  }\n  if (onRenderMap.has(elem)) {\n    elemFunctions.push(onRenderMap.get(elem));\n  }\n  if (onCleanupMap.has(elem)) {\n    elemFunctions.push(onCleanupMap.get(elem));\n  }\n  if (onRenderMap.has(where)) {\n    whereFunctions.push(onRenderMap.get(where));\n  }\n  if (onCleanupMap.has(where)) {\n    whereFunctions.push(onCleanupMap.get(where));\n  }\n  if (elemFunctions.length !== whereFunctions.length) return false;\n  if (String(elemFunctions) !== String(whereFunctions)) return false;\n  for (let i = 0; i < elem.childNodes.length; i++) {\n    if (onlyTextChildren) {\n      if (isTextNode(elem.childNodes[i])) {\n        if (!compareEvents(elem.childNodes[i], where.childNodes[i], onlyTextChildren)) {\n          return false;\n        }\n      }\n    } else {\n      if (!compareEvents(elem.childNodes[i], where.childNodes[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction compare(elem, where, onlyTextChildren) {\n  if (isDocumentFragment(elem) || isDocumentFragment(where)) return false;\n  return elem.isEqualNode(where) && compareEvents(elem, where, onlyTextChildren);\n}\nfunction render(elem, where = \"\", shouldSchedule = globalSchedule) {\n  /* c8 ignore next 4 */\n  if (shouldSchedule) {\n    schedule(render, elem, where, false);\n    return unmount(elem);\n  }\n  // Get elem value if elem is reactiveObject\n  if (Reflect.has(elem, reactiveSymbol)) {\n    elem = getValue(elem);\n  }\n  // Store elements of documentFragment for later unmount\n  let elemChildren = [];\n  if (isDocumentFragment(elem)) {\n    elemChildren = Array.from(elem.childNodes);\n    fragmentToElements.set(elem, elemChildren); // For diffing later\n  }\n\n  if (!where) {\n    document.body.append(elem);\n  } else {\n    if (typeof where === \"string\" /* Placeholder.string */) {\n      const resolveStringToElement = $(where);\n      if (resolveStringToElement) {\n        where = resolveStringToElement;\n      } else {\n        return noop;\n      }\n    }\n    if (!reuseElements) {\n      replaceElement(elem, where);\n    } else {\n      if (isTextNode(elem)) {\n        replaceElement(elem, where);\n      } else if (!compare(elem, where)) {\n        treeDiff(elem, where);\n      }\n    }\n  }\n  runLifecyle(elem, onRenderMap);\n  for (const subElem of elemChildren) {\n    runLifecyle(subElem, onRenderMap);\n  }\n  return unmount(isDocumentFragment(elem) ? elemChildren : elem);\n}\nfunction noop() {}\nfunction executeLifecycle(node, lifecyleMap) {\n  if (lifecyleMap.has(node)) {\n    const fn = lifecyleMap.get(node);\n    if (globalSchedule) {\n      window.requestIdleCallback(fn);\n    } else {\n      fn();\n    }\n    lifecyleMap.delete(node);\n  }\n}\nfunction runLifecyle(node, lifecyleMap) {\n  if (lifecyleMap === onRenderMap && !calledOnRender || lifecyleMap === onCleanupMap && !calledOnCleanup) return;\n  executeLifecycle(node, lifecyleMap);\n  const elements = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n  let subElem;\n  while (subElem = elements.nextNode()) {\n    executeLifecycle(subElem, lifecyleMap);\n    let childNode = subElem.firstChild;\n    while (childNode) {\n      if (isTextNode(childNode)) {\n        executeLifecycle(childNode, lifecyleMap);\n      }\n      childNode = childNode.nextSibling;\n    }\n  }\n}\nfunction filterTag2Elements(tag2Elements, root) {\n  for (const [localName, list] of tag2Elements.entries()) {\n    for (let i = 0; i < list.length; i++) {\n      const elem = list[i];\n      if (root.contains(elem) || root.isSameNode(elem)) {\n        list.splice(i, 1);\n        i--;\n      }\n      if (list.length === 0) {\n        tag2Elements.delete(localName);\n      }\n    }\n  }\n}\nfunction treeDiff(elem, where) {\n  let elemElements = [...elem.querySelectorAll(\"*\")];\n  if (!isDocumentFragment(elem)) elemElements.unshift(elem);\n  let whereElements = [];\n  if (!isTextNode(where)) {\n    whereElements = [...where.querySelectorAll(\"*\")];\n    if (!isDocumentFragment(where)) whereElements.unshift(where);\n  }\n  let template;\n  if (insertBeforeDiffing) {\n    template = document.createElement(\"template\" /* Placeholder.template */);\n    /* c8 ignore next 3 */\n    if (where === document.documentElement) {\n      where.append(template);\n    } else {\n      if (isDocumentFragment(where)) {\n        fragmentToElements.get(where)[0].before(template);\n      } else {\n        where.before(template);\n      }\n    }\n    template.append(elem);\n  }\n  // Create Mapping for easier diffing, eg: \"div\" -> [...Element]\n  const tag2Elements = new Map();\n  for (const wElem of whereElements) {\n    /* c8 ignore next 2 */\n    if (insertBeforeDiffing && wElem === template) return;\n    if (tag2Elements.has(wElem.localName)) {\n      tag2Elements.get(wElem.localName).push(wElem);\n    } else {\n      tag2Elements.set(wElem.localName, [wElem]);\n    }\n  }\n  // Re-use any where Element if possible, then remove elem Element\n  for (const subElem of elemElements) {\n    const sameElements = tag2Elements.get(subElem.localName);\n    if (sameElements) {\n      for (const whereElem of sameElements) {\n        if (compare(subElem, whereElem, true)) {\n          subElem.replaceWith(whereElem);\n          runLifecyle(subElem, onCleanupMap);\n          filterTag2Elements(tag2Elements, whereElem);\n          break;\n        }\n      }\n    }\n  }\n  if (insertBeforeDiffing) {\n    const newElems = isDocumentFragment(elem) ? Array.from(template.childNodes) : [elem];\n    if (isDocumentFragment(where)) {\n      const oldElems = fragmentToElements.get(where);\n      for (const e of newElems) oldElems[0].before(e);\n      for (const e of oldElems) e.remove();\n    } else {\n      where.replaceWith(...newElems);\n    }\n    template.remove();\n    runLifecyle(where, onCleanupMap);\n  } else {\n    replaceElement(elem, where);\n  }\n  tag2Elements.clear();\n}\nfunction replaceElement(elem, where) {\n  if (isDocumentFragment(where)) {\n    const fragmentChildren = fragmentToElements.get(where);\n    if (isDocumentFragment(elem)) {\n      const fragmentElements = Array.from(elem.childNodes);\n      for (let index = 0; index < fragmentChildren.length; index++) {\n        const fragWhere = fragmentChildren[index];\n        if (index < fragmentElements.length) {\n          render(fragmentElements[index], fragWhere);\n        } else {\n          fragWhere.remove();\n        }\n      }\n    } else {\n      for (let index = 0; index < fragmentChildren.length; index++) {\n        const fragWhere = fragmentChildren[index];\n        if (index === 0) {\n          render(elem, fragWhere);\n        } else {\n          fragWhere.remove();\n        }\n      }\n    }\n  } else {\n    where.replaceWith(elem);\n  }\n  runLifecyle(where, onCleanupMap);\n}\nfunction unmount(elem) {\n  if (Array.isArray(elem)) {\n    return () => elem.forEach(removeElement);\n  } else {\n    return () => removeElement(elem);\n  }\n}\nfunction removeElement(elem) {\n  if (elem.isConnected) {\n    elem.remove();\n    runLifecyle(elem, onCleanupMap);\n  }\n}\n/* c8 ignore next 13 */\nfunction schedule(fn, ...args) {\n  if (navigator.scheduling) {\n    if (navigator.scheduling.isInputPending()) {\n      setTimeout(schedule, 0, fn, ...args);\n    } else {\n      fn(...args);\n    }\n  } else {\n    window.requestIdleCallback(() => fn(...args));\n  }\n}\nfunction reactive(initial) {\n  let key;\n  do key = randomText(); while (Reflect.has(hydro, key));\n  Reflect.set(hydro, key, initial);\n  Reflect.set(setter, reactiveSymbol, true);\n  const chainKeysProxy = chainKeys(setter, [key]);\n  return chainKeysProxy;\n  function setter(val) {\n    const keys =\n    // @ts-ignore\n    (this && Reflect.has(this, reactiveSymbol) ? this : chainKeysProxy)[keysSymbol.description];\n    const [resolvedValue, resolvedObj] = resolveObject(keys);\n    const lastProp = keys[keys.length - 1];\n    if (isFunction(val)) {\n      const returnVal = val(resolvedValue);\n      const sameObject = resolvedValue === returnVal;\n      if (sameObject) return;\n      Reflect.set(resolvedObj, lastProp, returnVal ?? resolvedValue);\n    } else {\n      Reflect.set(resolvedObj, lastProp, val);\n    }\n  }\n}\nfunction chainKeys(initial, keys) {\n  return new Proxy(initial, {\n    get(target, subKey, _receiver) {\n      if (subKey === reactiveSymbol.description) return true;\n      if (subKey === keysSymbol.description) {\n        return keys;\n      }\n      if (subKey === Symbol.toPrimitive) {\n        return () => `{{${keys.join(\".\")}}}`;\n      }\n      return chainKeys(target, [...keys, subKey]);\n    }\n  });\n}\nfunction getReactiveKeys(reactiveHydro) {\n  const keys = reactiveHydro[keysSymbol.description];\n  const lastProp = keys[keys.length - 1];\n  return [lastProp, keys.length === 1];\n}\nfunction unset(reactiveHydro) {\n  const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    Reflect.set(hydro, lastProp, null);\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    Reflect.set(resolvedObj, lastProp, null);\n  }\n}\nfunction setAsyncUpdate(reactiveHydro, asyncUpdate) {\n  const [_, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    hydro.asyncUpdate = asyncUpdate;\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    resolvedObj.asyncUpdate = asyncUpdate;\n  }\n}\nfunction observe(reactiveHydro, fn) {\n  const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    hydro.observe(lastProp, fn);\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    resolvedObj.observe(lastProp, fn);\n  }\n}\nfunction unobserve(reactiveHydro) {\n  const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    hydro.unobserve(lastProp);\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    resolvedObj.unobserve(lastProp);\n  }\n}\nfunction ternary(condition, trueVal, falseVal, reactiveHydro = condition) {\n  const checkCondition = cond => (!Reflect.has(condition, reactiveSymbol) && isFunction(condition) ? condition(cond) : isPromise(cond) ? false : cond) ? isFunction(trueVal) ? trueVal() : trueVal : isFunction(falseVal) ? falseVal() : falseVal;\n  const ternaryValue = reactive(checkCondition(getValue(reactiveHydro)));\n  observe(reactiveHydro, newVal => {\n    newVal === null ? unset(ternaryValue) : ternaryValue(checkCondition(newVal));\n  });\n  return ternaryValue;\n}\nfunction emit(eventName, data, who, options = {\n  bubbles: true\n}) {\n  who.dispatchEvent(new CustomEvent(eventName, {\n    ...options,\n    detail: data\n  }));\n}\nlet trackDeps = false;\nconst trackProxies = new Set();\nconst trackMap = new WeakMap();\nconst unobserveMap = new WeakMap();\nfunction watchEffect(fn) {\n  trackDeps = true;\n  fn();\n  trackDeps = false;\n  const reRun = newVal => {\n    if (newVal !== null) fn();\n  };\n  for (const proxy of trackProxies) {\n    if (!trackMap.has(proxy)) continue;\n    for (const key of trackMap.get(proxy)) {\n      proxy.observe(key, reRun);\n      if (unobserveMap.has(reRun)) {\n        unobserveMap.get(reRun).push({\n          proxy,\n          key\n        });\n      } else {\n        unobserveMap.set(reRun, [{\n          proxy,\n          key\n        }]);\n      }\n    }\n    trackMap.delete(proxy);\n  }\n  trackProxies.clear();\n  return () => unobserveMap.get(reRun).forEach(entry => entry.proxy.unobserve(entry.key, reRun));\n}\nfunction getValue(reactiveHydro) {\n  const [resolvedValue] = resolveObject(Reflect.get(reactiveHydro, keysSymbol.description));\n  return resolvedValue;\n}\nlet calledOnRender = false;\nfunction onRender(fn, elem, ...args) {\n  calledOnRender = true;\n  onRenderMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\nlet calledOnCleanup = false;\nfunction onCleanup(fn, elem, ...args) {\n  calledOnCleanup = true;\n  onCleanupMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\n// Core of the library\nfunction generateProxy(obj) {\n  const handlers = Symbol(\"handlers\"); // For observer pattern\n  const boundFunctions = new WeakMap();\n  const proxy = new Proxy(obj ?? {}, {\n    // If receiver is a getter, then it is the object on which the search first started for the property|key -> Proxy\n    set(target, key, val, receiver) {\n      if (trackDeps) {\n        trackProxies.add(receiver);\n        if (trackMap.has(receiver)) {\n          trackMap.get(receiver).add(key);\n        } else {\n          trackMap.set(receiver, new Set([key]));\n        }\n      }\n      let returnSet = true;\n      let oldVal = Reflect.get(target, key, receiver);\n      if (oldVal === val) return returnSet;\n      // Reset Path - mostly GC\n      if (val === null) {\n        // Remove entry from reactitivyMap underlying Map\n        if (reactivityMap.has(receiver)) {\n          const key2NodeMap = reactivityMap.get(receiver);\n          key2NodeMap.delete(String(key));\n          if (key2NodeMap.size === 0) {\n            reactivityMap.delete(receiver);\n          }\n        }\n        // Inform the Observers about null change and unobserve\n        const observer = Reflect.get(target, handlers, receiver);\n        if (observer.has(key)) {\n          let set = observer.get(key);\n          for (const handler of set) {\n            handler(null, oldVal);\n          }\n          set.clear();\n          receiver.unobserve(key);\n        }\n        // If oldVal is a Proxy - clean it\n        if (isObject(oldVal) && isProxy(oldVal)) {\n          reactivityMap.delete(oldVal);\n          if (bindMap.has(oldVal)) {\n            bindMap.get(oldVal).forEach(removeElement);\n            bindMap.delete(oldVal);\n          }\n        } else {\n          if (bindMap.has(receiver)) {\n            bindMap.get(receiver).forEach(removeElement);\n            bindMap.delete(receiver);\n          }\n        }\n        // Remove item from array\n        /* c8 ignore next 4 */\n        if (!internReset && Array.isArray(receiver)) {\n          receiver.splice(Number(key), 1);\n          return returnSet;\n        }\n        return Reflect.deleteProperty(receiver, key);\n      }\n      // Set the value\n      if (isPromise(val)) {\n        const promise = val;\n        promise.then(value => {\n          // No Reflect in order to trigger the Getter\n          receiver[key] = value;\n        }).catch(e => {\n          console.error(e);\n          receiver[key] = null;\n        });\n        returnSet = Reflect.set(target, key, val, receiver);\n        return returnSet;\n      } else if (isNode(val)) {\n        returnSet = Reflect.set(target, key, val, receiver);\n      } else if (isObject(val) && !isProxy(val)) {\n        returnSet = Reflect.set(target, key, generateProxy(val), receiver);\n        // Recursively set properties to Proxys too\n        for (const [subKey, subVal] of Object.entries(val)) {\n          if (isObject(subVal) && !isProxy(subVal)) {\n            Reflect.set(val, subKey, generateProxy(subVal));\n          }\n        }\n      } else {\n        if (!reuseElements && Array.isArray(receiver) && receiver.includes(oldVal) && receiver.includes(val) && /* c8 ignore start */\n        bindMap.has(val)) {\n          const [elem] = bindMap.get(val);\n          if (lastSwapElem !== elem) {\n            const [oldElem] = bindMap.get(oldVal);\n            lastSwapElem = oldElem;\n            const prevElem = elem.previousSibling;\n            const prevOldElem = oldElem.previousSibling;\n            // Move it in the array too without triggering the proxy set\n            const index = receiver.findIndex(i => i === val);\n            receiver.splice(Number(key), 1, val);\n            receiver.splice(index, 1, oldVal);\n            prevElem.after(oldElem);\n            prevOldElem.after(elem);\n          }\n          return true;\n        } else {\n          /* c8 ignore end */\n          returnSet = Reflect.set(target, key, val, receiver);\n        }\n      }\n      const newVal = Reflect.get(target, key, receiver);\n      // Check if DOM needs to be updated\n      // oldVal can be Proxy value too\n      if (reactivityMap.has(oldVal)) {\n        checkReactivityMap(oldVal, key, newVal, oldVal);\n      } else if (reactivityMap.has(receiver)) {\n        checkReactivityMap(receiver, key, newVal, oldVal);\n      }\n      // current val (before setting) is a proxy - take over its keyToNodeMap\n      if (isObject(val) && isProxy(val)) {\n        if (reactivityMap.has(oldVal)) {\n          // Store old reactivityMap if it is a swap operation\n          reuseElements && tmpSwap.set(oldVal, reactivityMap.get(oldVal));\n          if (tmpSwap.has(val)) {\n            reactivityMap.set(oldVal, tmpSwap.get(val));\n            tmpSwap.delete(val);\n          } else {\n            reactivityMap.set(oldVal, reactivityMap.get(val));\n          }\n        }\n      }\n      // Inform the Observers\n      if (returnSet) {\n        Reflect.get(target, handlers, receiver).get(key)?.forEach(handler => handler(newVal, oldVal));\n      }\n      // If oldVal is a Proxy - clean it\n      !reuseElements && oldVal && cleanProxy(oldVal);\n      return returnSet;\n    },\n    // fix proxy bugs, e.g Map\n    get(target, prop, receiver) {\n      if (trackDeps) {\n        trackProxies.add(receiver);\n        if (trackMap.has(receiver)) {\n          trackMap.get(receiver).add(prop);\n        } else {\n          trackMap.set(receiver, new Set([prop]));\n        }\n      }\n      const value = Reflect.get(target, prop, receiver);\n      if (!isFunction(value)) {\n        return value;\n      }\n      if (!boundFunctions.has(value)) {\n        boundFunctions.set(value, value.bind(target));\n      }\n      return boundFunctions.get(value);\n    }\n  });\n  Reflect.defineProperty(proxy, \"isProxy\" /* Placeholder.isProxy */, {\n    value: true\n  });\n  Reflect.defineProperty(proxy, \"asyncUpdate\" /* Placeholder.asyncUpdate */, {\n    value: globalSchedule,\n    writable: true\n  });\n  Reflect.defineProperty(proxy, handlers, {\n    value: new Map()\n  });\n  Reflect.defineProperty(proxy, \"observe\" /* Placeholder.observe */, {\n    value(key, handler) {\n      const map = Reflect.get(proxy, handlers);\n      if (map.has(key)) {\n        map.get(key).add(handler);\n      } else {\n        map.set(key, new Set([handler]));\n      }\n    },\n    configurable: true\n  });\n  Reflect.defineProperty(proxy, \"getObservers\" /* Placeholder.getObservers */, {\n    value() {\n      return Reflect.get(proxy, handlers);\n    },\n    configurable: true\n  });\n  Reflect.defineProperty(proxy, \"unobserve\" /* Placeholder.unobserve */, {\n    value(key, handler) {\n      const map = Reflect.get(proxy, handlers);\n      if (key) {\n        if (map.has(key)) {\n          if (handler == null) {\n            map.delete(key);\n          } else {\n            const set = map.get(key);\n            if (set?.has(handler)) {\n              set.delete(handler);\n            }\n          }\n        }\n        /* c8 ignore next 3 */\n      } else {\n        map.clear();\n      }\n    },\n    configurable: true\n  });\n  if (!obj) Reflect.defineProperty(proxy, _boundFunctions, {\n    value: boundFunctions\n  });\n  return proxy;\n}\nfunction cleanProxy(proxy) {\n  if (isObject(proxy) && isProxy(proxy)) {\n    reactivityMap.delete(proxy);\n    /* c8 ignore next 4 */\n    if (bindMap.has(proxy)) {\n      bindMap.get(proxy).forEach(removeElement);\n      bindMap.delete(proxy);\n    }\n  }\n}\nfunction checkReactivityMap(obj, key, val, oldVal) {\n  const keyToNodeMap = reactivityMap.get(obj);\n  const nodeToChangeMap = keyToNodeMap.get(String(key));\n  if (nodeToChangeMap) {\n    /* c8 ignore next 5 */\n    if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n      schedule(updateDOM, nodeToChangeMap, val, oldVal);\n    } else {\n      updateDOM(nodeToChangeMap, val, oldVal);\n    }\n  }\n  if (isObject(val)) {\n    for (const [subKey, subVal] of Object.entries(val)) {\n      const subOldVal = isObject(oldVal) && Reflect.get(oldVal, subKey) || oldVal;\n      const nodeToChangeMap = keyToNodeMap.get(subKey);\n      if (nodeToChangeMap) {\n        /* c8 ignore next 5 */\n        if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n          schedule(updateDOM, nodeToChangeMap, subVal, subOldVal);\n        } else {\n          updateDOM(nodeToChangeMap, subVal, subOldVal);\n        }\n      }\n    }\n  }\n}\nfunction updateDOM(nodeToChangeMap, val, oldVal) {\n  nodeToChangeMap.forEach(entry => {\n    // Circular reference in order to keep Memory low\n    if (isNode(entry)) {\n      /* c8 ignore next 5 */\n      if (!entry.isConnected) {\n        const tmpChange = nodeToChangeMap.get(entry);\n        nodeToChangeMap.delete(entry);\n        nodeToChangeMap.delete(tmpChange);\n      }\n      return; // Continue in forEach\n    }\n    // For each change of the node update either attribute or textContent\n    for (const change of entry) {\n      const node = nodeToChangeMap.get(entry);\n      const [start, end, key] = change;\n      let useStartEnd = false;\n      if (isNode(val)) {\n        replaceElement(val, node);\n        if (val !== node) {\n          nodeToChangeMap.delete(node);\n          if (!isDocumentFragment(val)) {\n            nodeToChangeMap.set(val, entry);\n            nodeToChangeMap.set(entry, val);\n          }\n        }\n      } else if (isTextNode(node)) {\n        useStartEnd = true;\n        let text = node.nodeValue;\n        node.nodeValue = text.substring(0, start) + String(val) + text.substring(end);\n      } else {\n        if (key === \"two-way\" /* Placeholder.twoWay */) {\n          if (node instanceof HTMLInputElement && node.type === \"radio\" /* Placeholder.radio */) {\n            node.checked = Array.isArray(val) ? val.includes(node.name) : String(val) === node.value;\n          } else if (node instanceof HTMLInputElement && node.type === \"checkbox\" /* Placeholder.checkbox */) {\n            node.checked = val;\n          } else if (node instanceof HTMLTextAreaElement || node instanceof HTMLSelectElement || node instanceof HTMLInputElement) {\n            node.value = String(val);\n          }\n        } else if (isFunction(val) || isEventObject(val)) {\n          const eventName = key.replace(onEventRegex, \"\");\n          node.removeEventListener(eventName, isFunction(oldVal) ? oldVal : oldVal.event);\n          addEventListener(node, eventName, val);\n        } else if (isObject(val)) {\n          for (const [subKey, subVal] of Object.entries(val)) {\n            if (isFunction(subVal) || isEventObject(subVal)) {\n              const eventName = subKey.replace(onEventRegex, \"\");\n              node.removeEventListener(eventName, isFunction(oldVal[subKey]) ? oldVal[subKey] : oldVal[subKey].event);\n              addEventListener(node, eventName, subVal);\n            } else {\n              setAttribute(node, subKey, subVal);\n            }\n          }\n        } else {\n          useStartEnd = true;\n          let attr = node.getAttribute(key);\n          if (attr) {\n            attr = attr.substring(0, start) + String(val) + attr.substring(end);\n            setAttribute(node, key, attr === String(val) ? val : attr);\n          } else {\n            setAttribute(node, key, val);\n          }\n        }\n      }\n      if (useStartEnd) {\n        // Update end\n        change[1] = start + String(val).length;\n        // Because we updated the end, we also have to update the start and end for every other reactive change in the node, for the same key\n        if (allNodeChanges.has(node)) {\n          let passedNode = false;\n          for (const nodeChange of allNodeChanges.get(node)) {\n            if (nodeChange === change) {\n              passedNode = true;\n              continue;\n            }\n            if (passedNode && (isTextNode(node) || key === nodeChange[2])) {\n              const difference = String(oldVal).length - String(val).length;\n              nodeChange[0] -= difference;\n              nodeChange[1] -= difference;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction view(root, data, renderFunction) {\n  viewElements = true;\n  const rootElem = $(root);\n  const elements = getValue(data).map(renderFunction);\n  rootElem.append(...elements);\n  for (const elem of elements) runLifecyle(elem, onRenderMap);\n  if (rootElem.hasChildNodes()) setReactivity(rootElem);\n  onCleanup(unset, rootElem, data);\n  viewElements = false;\n  observe(data, (newData, oldData) => {\n    /* c8 ignore start */\n    viewElements = true;\n    // Reset or re-use\n    if (!newData?.length || !reuseElements && newData?.length === oldData?.length) {\n      rootElem.textContent = \"\";\n    } else if (reuseElements) {\n      for (let i = 0; i < oldData?.length && newData?.length; i++) {\n        oldData[i].id = newData[i].id;\n        oldData[i].label = newData[i].label;\n        newData[i] = oldData[i];\n      }\n    }\n    // Add to existing\n    if (oldData?.length && newData?.length > oldData?.length && newData[0] === oldData[0]) {\n      const length = oldData.length;\n      const slicedData = newData.slice(length);\n      const newElements = slicedData.map((item, i) => renderFunction(item, i + length));\n      rootElem.append(...newElements);\n      for (const elem of newElements) runLifecyle(elem, onRenderMap);\n    }\n    // Add new\n    else if (oldData?.length === 0 || !reuseElements && newData?.length) {\n      if (!reuseElements && oldData?.length && rootElem.hasChildNodes()) {\n        rootElem.textContent = \"\";\n      }\n      const elements = newData.map(renderFunction);\n      rootElem.append(...elements);\n      for (const elem of elements) runLifecyle(elem, onRenderMap);\n    }\n    if (rootElem.hasChildNodes()) setReactivity(rootElem);\n    viewElements = false;\n    /* c8 ignore end */\n  });\n}\n\nconst hydro = generateProxy();\nconst $ = document.querySelector.bind(document);\nconst $$ = document.querySelectorAll.bind(document);\nconst internals = {\n  compare\n};\nexport { render, html, h, hydro, setGlobalSchedule, setReuseElements, setInsertDiffing, setShouldSetReactivity, reactive, unset, setAsyncUpdate, unobserve, observe, ternary, emit, watchEffect, internals, getValue, onRender, onCleanup, setReactivity, $, $$, view };","map":{"version":3,"names":["window","requestIdleCallback","cb","_","start","performance","now","setTimeout","didTimeout","timeRemaining","Math","max","range","document","createRange","selectNodeContents","createContextualFragment","lastChild","parser","bind","allNodeChanges","WeakMap","elemEventFunctions","reactivityMap","bindMap","tmpSwap","onRenderMap","onCleanupMap","fragmentToElements","_boundFunctions","Symbol","reactiveSymbol","keysSymbol","globalSchedule","reuseElements","insertBeforeDiffing","shouldSetReactivity","viewElements","reactivityRegex","HTML_FIND_INVALID","newLineRegex","propChainRegex","onEventRegex","boolAttrList","lastSwapElem","internReset","isObject","obj","isFunction","func","isTextNode","node","splitText","undefined","isNode","Node","isDocumentFragment","nodeType","isEventObject","isProxy","hydroObject","Reflect","get","isPromise","then","randomText","randomChars","result","i","charAt","floor","random","length","setGlobalSchedule","willSchedule","setHydroRecursive","hydro","setReuseElements","willReuse","setInsertDiffing","willInsert","setShouldSetReactivity","willSet","set","value","Object","values","setAttribute","key","val","includes","removeAttribute","addEventListener","eventName","event","options","html","htmlArray","variables","eventFunctions","insertNodes","resolvedVariables","variable","template","push","has","String","funcName","Array","isArray","index","item","join","entries","DOMString","raw","trim","replace","DOM","fillDOM","childNodes","firstChild","createTextNode","elem","root","createNodeIterator","NodeFilter","SHOW_ELEMENT","acceptNode","element","localName","endsWith","FILTER_ACCEPT","FILTER_REJECT","nextNode","tag","replacement","createElement","append","getAttributeNames","getAttribute","replaceWith","querySelectorAll","shift","setReactivity","h","name","props","children","some","map","getChildren","flat","child","setReactivitySingle","elems","startsWith","childNode","nodeValue","nextSibling","attr_OR_text","match","hydroMatch","hydroPath","properties","split","filter","Boolean","resolvedValue","resolvedObj","resolveObject","lastProp","end","after","setTraces","textContent","JSON","stringify","proxy","HTMLSelectElement","changeAttrVal","HTMLInputElement","type","checked","HTMLTextAreaElement","subKey","subVal","isChecked","changeHandler","onCleanup","removeEventListener","target","hydroKey","change","changeArr","keyToNodeMap","nodeToChangeMap","Map","propertyArray","prev","prop","compareEvents","where","onlyTextChildren","elemFunctions","whereFunctions","compare","isEqualNode","render","shouldSchedule","schedule","unmount","getValue","elemChildren","from","body","resolveStringToElement","$","noop","replaceElement","treeDiff","runLifecyle","subElem","executeLifecycle","lifecyleMap","fn","delete","calledOnRender","calledOnCleanup","elements","filterTag2Elements","tag2Elements","list","contains","isSameNode","splice","elemElements","unshift","whereElements","documentElement","before","wElem","sameElements","whereElem","newElems","oldElems","e","remove","clear","fragmentChildren","fragmentElements","fragWhere","forEach","removeElement","isConnected","args","navigator","scheduling","isInputPending","reactive","initial","setter","chainKeysProxy","chainKeys","keys","description","returnVal","sameObject","Proxy","_receiver","toPrimitive","getReactiveKeys","reactiveHydro","unset","oneKey","setAsyncUpdate","asyncUpdate","observe","unobserve","ternary","condition","trueVal","falseVal","checkCondition","cond","ternaryValue","newVal","emit","data","who","bubbles","dispatchEvent","CustomEvent","detail","trackDeps","trackProxies","Set","trackMap","unobserveMap","watchEffect","reRun","entry","onRender","generateProxy","handlers","boundFunctions","receiver","add","returnSet","oldVal","key2NodeMap","size","observer","handler","Number","deleteProperty","promise","catch","console","error","oldElem","prevElem","previousSibling","prevOldElem","findIndex","checkReactivityMap","cleanProxy","defineProperty","writable","configurable","updateDOM","subOldVal","tmpChange","useStartEnd","text","substring","attr","passedNode","nodeChange","difference","view","renderFunction","rootElem","hasChildNodes","newData","oldData","id","label","slicedData","slice","newElements","querySelector","$$","internals"],"sources":["C:/Users/Garima/OneDrive/Desktop/iiim/node_modules/hydro-js/dist/library.js"],"sourcesContent":["// Safari Polyfills\nwindow.requestIdleCallback =\n    /* c8 ignore next 4 */\n    window.requestIdleCallback ||\n        ((cb, _, start = performance.now()) => setTimeout(cb, 0, {\n            didTimeout: false,\n            timeRemaining: () => Math.max(0, 5 - (performance.now() - start)),\n        }));\n// Safari Polyfills END\nconst range = document.createRange();\nrange.selectNodeContents(range.createContextualFragment(`<${\"template\" /* Placeholder.template */}>`).lastChild);\nconst parser = range.createContextualFragment.bind(range);\nconst allNodeChanges = new WeakMap(); // Maps a Node against an array of changes. An array is necessary because a node can have multiple variables for one text / attribute.\nconst elemEventFunctions = new WeakMap(); // Stores event functions in order to compare Elements against each other.\nconst reactivityMap = new WeakMap(); // Maps Proxy Objects to another Map(proxy-key, node).\nconst bindMap = new WeakMap(); // Bind an Element to data. If the data is being unset, the DOM Element disappears too.\nconst tmpSwap = new WeakMap(); // Take over keyToNodeMap if the new value is a hydro Proxy. Save old reactivityMap entry here, in case for a swap operation.\nconst onRenderMap = new WeakMap(); // Lifecycle Hook that is being called after rendering\nconst onCleanupMap = new WeakMap(); // Lifecycle Hook that is being called when unmount function is being called\nconst fragmentToElements = new WeakMap(); // Used to retreive Elements from DocumentFragment after it has been rendered â€“ for diffing\nconst _boundFunctions = Symbol(\"boundFunctions\"); // Cache for bound functions in Proxy, so that we create the bound version of each function only once\nconst reactiveSymbol = Symbol(\"reactive\");\nconst keysSymbol = Symbol(\"keys\");\nlet globalSchedule = true; // Decides whether to schedule rendering and updating (async)\nlet reuseElements = true; // Reuses Elements when rendering\nlet insertBeforeDiffing = false; // Makes sense in Chrome only\nlet shouldSetReactivity = true;\nlet viewElements = false;\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst HTML_FIND_INVALID = /<(\\/?)(html|head|body)(>|\\s.*?>)/g;\nconst newLineRegex = /\\n/g;\nconst propChainRegex = /[\\.\\[\\]]/;\nconst onEventRegex = /^on/;\n// https://html.spec.whatwg.org/#attributes-3\n// if value for bool attr is falsy, then remove attr\n// INFO: draggable and spellcheck are actually using booleans as string! Also, hidden is not really a bool attr, but is making use of the empty string too. Might consider to add 'translate' (yes and no as string)\nconst boolAttrList = [\n    \"allowfullscreen\",\n    \"async\",\n    \"autofocus\",\n    \"autoplay\",\n    \"checked\",\n    \"controls\",\n    \"draggable\",\n    \"default\",\n    \"defer\",\n    \"disabled\",\n    \"formnovalidate\",\n    \"hidden\",\n    \"inert\",\n    \"ismap\",\n    \"itemscope\",\n    \"loop\",\n    \"multiple\",\n    \"muted\",\n    \"nomodule\",\n    \"novalidate\",\n    \"open\",\n    \"playsinline\",\n    \"readonly\",\n    \"required\",\n    \"reversed\",\n    \"selected\",\n    \"spellcheck\",\n];\nlet lastSwapElem = null;\nlet internReset = false;\nfunction isObject(obj) {\n    return obj != null && typeof obj === \"object\";\n}\nfunction isFunction(func) {\n    return typeof func === \"function\" /* Placeholder.function */;\n}\nfunction isTextNode(node) {\n    return node.splitText !== undefined;\n}\nfunction isNode(node) {\n    return node instanceof Node;\n}\nfunction isDocumentFragment(node) {\n    return node.nodeType === 11;\n}\nfunction isEventObject(obj) {\n    return (isObject(obj) && \"event\" /* Placeholder.event */ in obj && \"options\" /* Placeholder.options */ in obj);\n}\nfunction isProxy(hydroObject) {\n    return Reflect.get(hydroObject, \"isProxy\" /* Placeholder.isProxy */);\n}\nfunction isPromise(obj) {\n    return isObject(obj) && typeof obj.then === \"function\";\n}\nfunction randomText() {\n    const randomChars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (var i = 0; i < 6; i++) {\n        result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n    }\n    return result;\n    // return Math.random().toString(32).slice(2);\n}\nfunction setGlobalSchedule(willSchedule) {\n    globalSchedule = willSchedule;\n    setHydroRecursive(hydro);\n}\nfunction setReuseElements(willReuse) {\n    reuseElements = willReuse;\n}\nfunction setInsertDiffing(willInsert) {\n    insertBeforeDiffing = willInsert;\n}\nfunction setShouldSetReactivity(willSet) {\n    shouldSetReactivity = willSet;\n}\nfunction setHydroRecursive(obj) {\n    Reflect.set(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */, globalSchedule);\n    for (const value of Object.values(obj)) {\n        if (isObject(value) && isProxy(value)) {\n            setHydroRecursive(value);\n        }\n    }\n}\nfunction setAttribute(node, key, val) {\n    if (boolAttrList.includes(key) && !val) {\n        node.removeAttribute(key);\n        return false;\n    }\n    node.setAttribute(key, val);\n    return true;\n}\nfunction addEventListener(node, eventName, obj) {\n    node.addEventListener(eventName, isFunction(obj) ? obj : obj.event, isFunction(obj) ? {} : obj.options);\n}\nfunction html(htmlArray, ...variables) {\n    const eventFunctions = {}; // Temporarily store a mapping for string -> function, because eventListener have to be registered after the Element's creation\n    let insertNodes = []; // Nodes, that will be added after the parsing\n    const resolvedVariables = [];\n    for (const variable of variables) {\n        const template = `<${\"template\" /* Placeholder.template */} id=\"lbInsertNodes\"></${\"template\" /* Placeholder.template */}>`;\n        switch (variable) {\n            case isNode(variable) && variable: {\n                insertNodes.push(variable);\n                resolvedVariables.push(template);\n                break;\n            }\n            case ([\n                \"number\",\n                \"string\" /* Placeholder.string */,\n                \"symbol\",\n                \"boolean\",\n                \"bigint\",\n            ].includes(typeof variable) ||\n                Reflect.has(variable, reactiveSymbol)) &&\n                variable:\n                {\n                    resolvedVariables.push(String(variable));\n                    break;\n                }\n            case (isFunction(variable) || isEventObject(variable)) && variable: {\n                const funcName = randomText();\n                Reflect.set(eventFunctions, funcName, variable);\n                resolvedVariables.push(funcName);\n                break;\n            }\n            case Array.isArray(variable) && variable: {\n                for (let index = 0; index < variable.length; index++) {\n                    const item = variable[index];\n                    if (isNode(item)) {\n                        insertNodes.push(item);\n                        variable[index] = template;\n                    }\n                }\n                resolvedVariables.push(variable.join(\"\"));\n                break;\n            }\n            case isObject(variable) && variable: {\n                let result = \"\";\n                for (const [key, value] of Object.entries(variable)) {\n                    if (isFunction(value) || isEventObject(value)) {\n                        const funcName = randomText();\n                        Reflect.set(eventFunctions, funcName, value);\n                        result += `${key}=\"${funcName}\"`;\n                    }\n                    else {\n                        result += `${key}=\"${value}\"`;\n                    }\n                }\n                resolvedVariables.push(result);\n                break;\n            }\n        }\n        /* c8 ignore next 1 */\n    }\n    // Find elements <html|head|body>, as they cannot be created by the parser. Replace them by fake Custom Elements and replace them afterwards.\n    let DOMString = String.raw(htmlArray, ...resolvedVariables).trim();\n    DOMString = DOMString.replace(HTML_FIND_INVALID, `<$1$2${\"-dummy\" /* Placeholder.dummy */}$3`);\n    const DOM = parser(DOMString);\n    // Delay Element iteration and manipulation after the elements have been added to the DOM.\n    if (!viewElements) {\n        fillDOM(DOM, insertNodes, eventFunctions);\n    }\n    // Return DocumentFragment\n    if (DOM.childNodes.length > 1)\n        return DOM;\n    // Return empty Text Node\n    if (!DOM.firstChild)\n        return document.createTextNode(\"\");\n    // Return Element | Text\n    return DOM.firstChild;\n}\nfunction fillDOM(elem, insertNodes, eventFunctions) {\n    const root = document.createNodeIterator(elem, NodeFilter.SHOW_ELEMENT, {\n        acceptNode(element) {\n            return element.localName.endsWith(\"-dummy\" /* Placeholder.dummy */)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_REJECT;\n        },\n    });\n    let nextNode;\n    while ((nextNode = root.nextNode())) {\n        const tag = nextNode.localName.replace(\"-dummy\" /* Placeholder.dummy */, \"\");\n        const replacement = document.createElement(tag);\n        replacement.append(...nextNode.childNodes);\n        /* c8 ignore next 3 */\n        for (const key of nextNode.getAttributeNames()) {\n            replacement.setAttribute(key, nextNode.getAttribute(key));\n        }\n        nextNode.replaceWith(replacement);\n    }\n    // Insert HTML Elements, which were stored in insertNodes\n    if (!isTextNode(elem)) {\n        for (const template of elem.querySelectorAll(\"template[id^=lbInsertNodes]\"))\n            template.replaceWith(insertNodes.shift());\n    }\n    if (shouldSetReactivity)\n        setReactivity(elem, eventFunctions);\n}\n/* c8 ignore start */\nfunction h(name, props, ...children) {\n    if (isFunction(name))\n        return name({ ...props, children });\n    const elem = document.createElement(name);\n    for (let i in props) {\n        i in elem && !boolAttrList.includes(i)\n            ? //@ts-ignore\n                (elem[i] = props[i])\n            : setAttribute(elem, i, props[i]);\n    }\n    elem.append(...(children.some((i) => Array.isArray(i))\n        ? children.map(getChildren).flat()\n        : children));\n    if (!viewElements) {\n        setReactivity(elem);\n    }\n    return elem;\n}\nfunction getChildren(child) {\n    return isObject(child) && !isNode(child)\n        ? Object.values(child)\n        : child;\n}\n/* c8 ignore end */\nfunction setReactivity(DOM, eventFunctions) {\n    if (isTextNode(DOM)) {\n        setReactivitySingle(DOM);\n        return;\n    }\n    const elems = document.createNodeIterator(DOM, NodeFilter.SHOW_ELEMENT);\n    let elem;\n    while ((elem = elems.nextNode())) {\n        for (const key of elem.getAttributeNames()) {\n            // Set functions\n            const val = elem.getAttribute(key);\n            if (eventFunctions && key.startsWith(\"on\")) {\n                const eventName = key.replace(onEventRegex, \"\");\n                const event = eventFunctions[val];\n                if (!event) {\n                    setReactivitySingle(elem, key, val);\n                    continue;\n                }\n                elem.removeAttribute(key);\n                if (isEventObject(event)) {\n                    elem.addEventListener(eventName, event.event, event.options);\n                    if (elemEventFunctions.has(elem)) {\n                        elemEventFunctions.get(elem).push(event.event);\n                    }\n                    else {\n                        elemEventFunctions.set(elem, [event.event]);\n                    }\n                }\n                else {\n                    elem.addEventListener(eventName, event);\n                    if (elemEventFunctions.has(elem)) {\n                        elemEventFunctions.get(elem).push(event);\n                    }\n                    else {\n                        elemEventFunctions.set(elem, [event]);\n                    }\n                }\n            }\n            else {\n                setReactivitySingle(elem, key, val);\n            }\n        }\n        let childNode = elem.firstChild;\n        while (childNode) {\n            if (isTextNode(childNode) && childNode.nodeValue?.includes(\"{{\")) {\n                setReactivitySingle(childNode);\n            }\n            childNode = childNode.nextSibling;\n        }\n    }\n}\nfunction setReactivitySingle(node, key, val) {\n    let attr_OR_text, match;\n    if (!key) {\n        attr_OR_text = node.nodeValue; // nodeValue is (always) defined on Text Nodes\n    }\n    else {\n        attr_OR_text = val;\n        if (attr_OR_text === \"\") {\n            // e.g. checked attribute or two-way attribute\n            attr_OR_text = key;\n            if (attr_OR_text.startsWith(\"{{\")) {\n                node.removeAttribute(attr_OR_text);\n            }\n        }\n    }\n    while ((match = attr_OR_text.match(reactivityRegex))) {\n        // attr_OR_text will be altered in every iteration\n        const [hydroMatch, hydroPath] = match;\n        const properties = hydroPath\n            .trim()\n            .replace(newLineRegex, \"\")\n            .split(propChainRegex)\n            .filter(Boolean);\n        const [resolvedValue, resolvedObj] = resolveObject(properties);\n        let lastProp = properties[properties.length - 1];\n        const start = match.index;\n        let end = start + String(resolvedValue).length;\n        if (isNode(resolvedValue)) {\n            node.nodeValue = attr_OR_text.replace(hydroMatch, \"\");\n            node.after(resolvedValue);\n            setTraces(start, end, resolvedValue, lastProp, resolvedObj, key);\n            return;\n        }\n        // Set Text or set Attribute\n        if (isTextNode(node)) {\n            const textContent = isObject(resolvedValue)\n                ? JSON.stringify(resolvedValue)\n                : resolvedValue ?? \"\";\n            attr_OR_text = attr_OR_text.replace(hydroMatch, textContent);\n            if (attr_OR_text != null) {\n                node.nodeValue = attr_OR_text;\n            }\n        }\n        else {\n            if (key === \"bind\") {\n                attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                node.removeAttribute(key);\n                const proxy = isObject(resolvedValue) && isProxy(resolvedValue)\n                    ? resolvedValue\n                    : resolvedObj;\n                if (bindMap.has(proxy)) {\n                    bindMap.get(proxy).push(node);\n                }\n                else {\n                    bindMap.set(proxy, [node]);\n                }\n                continue;\n            }\n            else if (key === \"two-way\" /* Placeholder.twoWay */) {\n                if (node instanceof HTMLSelectElement) {\n                    node.value = resolvedValue;\n                    changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n                }\n                else if (node instanceof HTMLInputElement &&\n                    node.type === \"radio\" /* Placeholder.radio */) {\n                    node.checked = node.value === resolvedValue;\n                    changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n                }\n                else if (node instanceof HTMLInputElement &&\n                    node.type === \"checkbox\" /* Placeholder.checkbox */) {\n                    node.checked = resolvedValue;\n                    changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp, true);\n                }\n                else if (node instanceof HTMLTextAreaElement ||\n                    node instanceof HTMLInputElement) {\n                    node.value = resolvedValue;\n                    changeAttrVal(\"input\", node, resolvedObj, lastProp);\n                }\n                attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                node.setAttribute(\"two-way\" /* Placeholder.twoWay */, \"\");\n            }\n            else if (isFunction(resolvedValue) || isEventObject(resolvedValue)) {\n                attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                node.removeAttribute(key);\n                addEventListener(node, key.replace(onEventRegex, \"\"), resolvedValue);\n            }\n            else if (isObject(resolvedValue)) {\n                // Case: setting attrs on Element - <p ${props}>\n                for (const [subKey, subVal] of Object.entries(resolvedValue)) {\n                    attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                    if (isFunction(subVal) || isEventObject(subVal)) {\n                        addEventListener(node, subKey.replace(onEventRegex, \"\"), subVal);\n                    }\n                    else {\n                        lastProp = subKey;\n                        if (setAttribute(node, subKey, subVal)) {\n                            end = start + String(subVal).length;\n                        }\n                        else {\n                            end = start;\n                        }\n                    }\n                    setTraces(start, end, node, lastProp, resolvedValue, subKey);\n                }\n                continue; // As we set all Mappings via subKeys\n            }\n            else {\n                attr_OR_text = attr_OR_text.replace(hydroMatch, resolvedValue);\n                if (!setAttribute(node, key, attr_OR_text === String(resolvedValue)\n                    ? resolvedValue\n                    : attr_OR_text)) {\n                    attr_OR_text = attr_OR_text.replace(resolvedValue, \"\");\n                }\n            }\n        }\n        setTraces(start, end, node, lastProp, resolvedObj, key);\n    }\n}\n// Same behavior as v-model in https://v3.vuejs.org/guide/forms.html#basic-usage\nfunction changeAttrVal(eventName, node, resolvedObj, lastProp, isChecked = false) {\n    node.addEventListener(eventName, changeHandler);\n    onCleanup(() => node.removeEventListener(eventName, changeHandler), node);\n    function changeHandler({ target }) {\n        Reflect.set(resolvedObj, lastProp, isChecked\n            ? target.checked\n            : target.value);\n    }\n}\nfunction setTraces(start, end, node, hydroKey, resolvedObj, key) {\n    // Set WeakMaps, that will be used to track a change for a Node but also to check if a Node has any other changes.\n    const change = [start, end, key];\n    const changeArr = [change];\n    if (allNodeChanges.has(node)) {\n        allNodeChanges.get(node).push(change);\n    }\n    else {\n        allNodeChanges.set(node, [change]); // Use own version. Otherwise changes, will lead to incorrect changes in the DOM.\n    }\n    if (reactivityMap.has(resolvedObj)) {\n        const keyToNodeMap = reactivityMap.get(resolvedObj);\n        const nodeToChangeMap = keyToNodeMap.get(hydroKey);\n        if (nodeToChangeMap) {\n            if (nodeToChangeMap.has(node)) {\n                nodeToChangeMap.get(node).push(change);\n            }\n            else {\n                nodeToChangeMap.set(changeArr, node);\n                nodeToChangeMap.set(node, changeArr);\n            }\n        }\n        else {\n            keyToNodeMap.set(hydroKey, \n            //@ts-ignore\n            new Map([\n                [changeArr, node],\n                [node, changeArr],\n            ]));\n        }\n    }\n    else {\n        reactivityMap.set(resolvedObj, new Map([\n            [\n                hydroKey,\n                //@ts-ignore\n                new Map([\n                    [changeArr, node],\n                    [node, changeArr],\n                ]),\n            ],\n        ]));\n    }\n}\n// Helper function to return a value and hydro obj from a chain of properties\nfunction resolveObject(propertyArray) {\n    let value, prev;\n    value = prev = hydro;\n    for (const prop of propertyArray) {\n        prev = value;\n        value = Reflect.get(prev, prop);\n    }\n    return [value, prev];\n}\nfunction compareEvents(elem, where, onlyTextChildren) {\n    const elemFunctions = [];\n    const whereFunctions = [];\n    if (isTextNode(elem)) {\n        if (onRenderMap.has(elem)) {\n            elemFunctions.push(onRenderMap.get(elem));\n        }\n        if (onCleanupMap.has(elem)) {\n            elemFunctions.push(onCleanupMap.get(elem));\n        }\n        if (onRenderMap.has(where)) {\n            whereFunctions.push(onRenderMap.get(where));\n        }\n        if (onCleanupMap.has(where)) {\n            whereFunctions.push(onCleanupMap.get(where));\n        }\n        if (elemFunctions.length !== whereFunctions.length)\n            return false;\n        if (String(elemFunctions) !== String(whereFunctions))\n            return false;\n        return true;\n    }\n    if (elemEventFunctions.has(elem)) {\n        elemFunctions.push(...elemEventFunctions.get(elem));\n    }\n    if (elemEventFunctions.has(where)) {\n        whereFunctions.push(...elemEventFunctions.get(where));\n    }\n    if (onRenderMap.has(elem)) {\n        elemFunctions.push(onRenderMap.get(elem));\n    }\n    if (onCleanupMap.has(elem)) {\n        elemFunctions.push(onCleanupMap.get(elem));\n    }\n    if (onRenderMap.has(where)) {\n        whereFunctions.push(onRenderMap.get(where));\n    }\n    if (onCleanupMap.has(where)) {\n        whereFunctions.push(onCleanupMap.get(where));\n    }\n    if (elemFunctions.length !== whereFunctions.length)\n        return false;\n    if (String(elemFunctions) !== String(whereFunctions))\n        return false;\n    for (let i = 0; i < elem.childNodes.length; i++) {\n        if (onlyTextChildren) {\n            if (isTextNode(elem.childNodes[i])) {\n                if (!compareEvents(elem.childNodes[i], where.childNodes[i], onlyTextChildren)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            if (!compareEvents(elem.childNodes[i], where.childNodes[i])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction compare(elem, where, onlyTextChildren) {\n    if (isDocumentFragment(elem) || isDocumentFragment(where))\n        return false;\n    return (elem.isEqualNode(where) && compareEvents(elem, where, onlyTextChildren));\n}\nfunction render(elem, where = \"\", shouldSchedule = globalSchedule) {\n    /* c8 ignore next 4 */\n    if (shouldSchedule) {\n        schedule(render, elem, where, false);\n        return unmount(elem);\n    }\n    // Get elem value if elem is reactiveObject\n    if (Reflect.has(elem, reactiveSymbol)) {\n        elem = getValue(elem);\n    }\n    // Store elements of documentFragment for later unmount\n    let elemChildren = [];\n    if (isDocumentFragment(elem)) {\n        elemChildren = Array.from(elem.childNodes);\n        fragmentToElements.set(elem, elemChildren); // For diffing later\n    }\n    if (!where) {\n        document.body.append(elem);\n    }\n    else {\n        if (typeof where === \"string\" /* Placeholder.string */) {\n            const resolveStringToElement = $(where);\n            if (resolveStringToElement) {\n                where = resolveStringToElement;\n            }\n            else {\n                return noop;\n            }\n        }\n        if (!reuseElements) {\n            replaceElement(elem, where);\n        }\n        else {\n            if (isTextNode(elem)) {\n                replaceElement(elem, where);\n            }\n            else if (!compare(elem, where)) {\n                treeDiff(elem, where);\n            }\n        }\n    }\n    runLifecyle(elem, onRenderMap);\n    for (const subElem of elemChildren) {\n        runLifecyle(subElem, onRenderMap);\n    }\n    return unmount(isDocumentFragment(elem) ? elemChildren : elem);\n}\nfunction noop() { }\nfunction executeLifecycle(node, lifecyleMap) {\n    if (lifecyleMap.has(node)) {\n        const fn = lifecyleMap.get(node);\n        if (globalSchedule) {\n            window.requestIdleCallback(fn);\n        }\n        else {\n            fn();\n        }\n        lifecyleMap.delete(node);\n    }\n}\nfunction runLifecyle(node, lifecyleMap) {\n    if ((lifecyleMap === onRenderMap && !calledOnRender) ||\n        (lifecyleMap === onCleanupMap && !calledOnCleanup))\n        return;\n    executeLifecycle(node, lifecyleMap);\n    const elements = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    let subElem;\n    while ((subElem = elements.nextNode())) {\n        executeLifecycle(subElem, lifecyleMap);\n        let childNode = subElem.firstChild;\n        while (childNode) {\n            if (isTextNode(childNode)) {\n                executeLifecycle(childNode, lifecyleMap);\n            }\n            childNode = childNode.nextSibling;\n        }\n    }\n}\nfunction filterTag2Elements(tag2Elements, root) {\n    for (const [localName, list] of tag2Elements.entries()) {\n        for (let i = 0; i < list.length; i++) {\n            const elem = list[i];\n            if (root.contains(elem) || root.isSameNode(elem)) {\n                list.splice(i, 1);\n                i--;\n            }\n            if (list.length === 0) {\n                tag2Elements.delete(localName);\n            }\n        }\n    }\n}\nfunction treeDiff(elem, where) {\n    let elemElements = [...elem.querySelectorAll(\"*\")];\n    if (!isDocumentFragment(elem))\n        elemElements.unshift(elem);\n    let whereElements = [];\n    if (!isTextNode(where)) {\n        whereElements = [...where.querySelectorAll(\"*\")];\n        if (!isDocumentFragment(where))\n            whereElements.unshift(where);\n    }\n    let template;\n    if (insertBeforeDiffing) {\n        template = document.createElement(\"template\" /* Placeholder.template */);\n        /* c8 ignore next 3 */\n        if (where === document.documentElement) {\n            where.append(template);\n        }\n        else {\n            if (isDocumentFragment(where)) {\n                fragmentToElements.get(where)[0].before(template);\n            }\n            else {\n                where.before(template);\n            }\n        }\n        template.append(elem);\n    }\n    // Create Mapping for easier diffing, eg: \"div\" -> [...Element]\n    const tag2Elements = new Map();\n    for (const wElem of whereElements) {\n        /* c8 ignore next 2 */\n        if (insertBeforeDiffing && wElem === template)\n            return;\n        if (tag2Elements.has(wElem.localName)) {\n            tag2Elements.get(wElem.localName).push(wElem);\n        }\n        else {\n            tag2Elements.set(wElem.localName, [wElem]);\n        }\n    }\n    // Re-use any where Element if possible, then remove elem Element\n    for (const subElem of elemElements) {\n        const sameElements = tag2Elements.get(subElem.localName);\n        if (sameElements) {\n            for (const whereElem of sameElements) {\n                if (compare(subElem, whereElem, true)) {\n                    subElem.replaceWith(whereElem);\n                    runLifecyle(subElem, onCleanupMap);\n                    filterTag2Elements(tag2Elements, whereElem);\n                    break;\n                }\n            }\n        }\n    }\n    if (insertBeforeDiffing) {\n        const newElems = isDocumentFragment(elem)\n            ? Array.from(template.childNodes)\n            : [elem];\n        if (isDocumentFragment(where)) {\n            const oldElems = fragmentToElements.get(where);\n            for (const e of newElems)\n                oldElems[0].before(e);\n            for (const e of oldElems)\n                e.remove();\n        }\n        else {\n            where.replaceWith(...newElems);\n        }\n        template.remove();\n        runLifecyle(where, onCleanupMap);\n    }\n    else {\n        replaceElement(elem, where);\n    }\n    tag2Elements.clear();\n}\nfunction replaceElement(elem, where) {\n    if (isDocumentFragment(where)) {\n        const fragmentChildren = fragmentToElements.get(where);\n        if (isDocumentFragment(elem)) {\n            const fragmentElements = Array.from(elem.childNodes);\n            for (let index = 0; index < fragmentChildren.length; index++) {\n                const fragWhere = fragmentChildren[index];\n                if (index < fragmentElements.length) {\n                    render(fragmentElements[index], fragWhere);\n                }\n                else {\n                    fragWhere.remove();\n                }\n            }\n        }\n        else {\n            for (let index = 0; index < fragmentChildren.length; index++) {\n                const fragWhere = fragmentChildren[index];\n                if (index === 0) {\n                    render(elem, fragWhere);\n                }\n                else {\n                    fragWhere.remove();\n                }\n            }\n        }\n    }\n    else {\n        where.replaceWith(elem);\n    }\n    runLifecyle(where, onCleanupMap);\n}\nfunction unmount(elem) {\n    if (Array.isArray(elem)) {\n        return () => elem.forEach(removeElement);\n    }\n    else {\n        return () => removeElement(elem);\n    }\n}\nfunction removeElement(elem) {\n    if (elem.isConnected) {\n        elem.remove();\n        runLifecyle(elem, onCleanupMap);\n    }\n}\n/* c8 ignore next 13 */\nfunction schedule(fn, ...args) {\n    if (navigator.scheduling) {\n        if (navigator.scheduling.isInputPending()) {\n            setTimeout(schedule, 0, fn, ...args);\n        }\n        else {\n            fn(...args);\n        }\n    }\n    else {\n        window.requestIdleCallback(() => fn(...args));\n    }\n}\nfunction reactive(initial) {\n    let key;\n    do\n        key = randomText();\n    while (Reflect.has(hydro, key));\n    Reflect.set(hydro, key, initial);\n    Reflect.set(setter, reactiveSymbol, true);\n    const chainKeysProxy = chainKeys(setter, [key]);\n    return chainKeysProxy;\n    function setter(val) {\n        const keys = // @ts-ignore\n         (this && Reflect.has(this, reactiveSymbol) ? this : chainKeysProxy)[keysSymbol.description];\n        const [resolvedValue, resolvedObj] = resolveObject(keys);\n        const lastProp = keys[keys.length - 1];\n        if (isFunction(val)) {\n            const returnVal = val(resolvedValue);\n            const sameObject = resolvedValue === returnVal;\n            if (sameObject)\n                return;\n            Reflect.set(resolvedObj, lastProp, returnVal ?? resolvedValue);\n        }\n        else {\n            Reflect.set(resolvedObj, lastProp, val);\n        }\n    }\n}\nfunction chainKeys(initial, keys) {\n    return new Proxy(initial, {\n        get(target, subKey, _receiver) {\n            if (subKey === reactiveSymbol.description)\n                return true;\n            if (subKey === keysSymbol.description) {\n                return keys;\n            }\n            if (subKey === Symbol.toPrimitive) {\n                return () => `{{${keys.join(\".\")}}}`;\n            }\n            return chainKeys(target, [...keys, subKey]);\n        },\n    });\n}\nfunction getReactiveKeys(reactiveHydro) {\n    const keys = reactiveHydro[keysSymbol.description];\n    const lastProp = keys[keys.length - 1];\n    return [lastProp, keys.length === 1];\n}\nfunction unset(reactiveHydro) {\n    const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        Reflect.set(hydro, lastProp, null);\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        Reflect.set(resolvedObj, lastProp, null);\n    }\n}\nfunction setAsyncUpdate(reactiveHydro, asyncUpdate) {\n    const [_, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        hydro.asyncUpdate = asyncUpdate;\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        resolvedObj.asyncUpdate = asyncUpdate;\n    }\n}\nfunction observe(reactiveHydro, fn) {\n    const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        hydro.observe(lastProp, fn);\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        resolvedObj.observe(lastProp, fn);\n    }\n}\nfunction unobserve(reactiveHydro) {\n    const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        hydro.unobserve(lastProp);\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        resolvedObj.unobserve(lastProp);\n    }\n}\nfunction ternary(condition, trueVal, falseVal, reactiveHydro = condition) {\n    const checkCondition = (cond) => (!Reflect.has(condition, reactiveSymbol) && isFunction(condition)\n        ? condition(cond)\n        : isPromise(cond)\n            ? false\n            : cond)\n        ? isFunction(trueVal)\n            ? trueVal()\n            : trueVal\n        : isFunction(falseVal)\n            ? falseVal()\n            : falseVal;\n    const ternaryValue = reactive(checkCondition(getValue(reactiveHydro)));\n    observe(reactiveHydro, (newVal) => {\n        newVal === null\n            ? unset(ternaryValue)\n            : ternaryValue(checkCondition(newVal));\n    });\n    return ternaryValue;\n}\nfunction emit(eventName, data, who, options = { bubbles: true }) {\n    who.dispatchEvent(new CustomEvent(eventName, { ...options, detail: data }));\n}\nlet trackDeps = false;\nconst trackProxies = new Set();\nconst trackMap = new WeakMap();\nconst unobserveMap = new WeakMap();\nfunction watchEffect(fn) {\n    trackDeps = true;\n    fn();\n    trackDeps = false;\n    const reRun = (newVal) => {\n        if (newVal !== null)\n            fn();\n    };\n    for (const proxy of trackProxies) {\n        if (!trackMap.has(proxy))\n            continue;\n        for (const key of trackMap.get(proxy)) {\n            proxy.observe(key, reRun);\n            if (unobserveMap.has(reRun)) {\n                unobserveMap.get(reRun).push({ proxy, key });\n            }\n            else {\n                unobserveMap.set(reRun, [{ proxy, key }]);\n            }\n        }\n        trackMap.delete(proxy);\n    }\n    trackProxies.clear();\n    return () => unobserveMap\n        .get(reRun)\n        .forEach((entry) => entry.proxy.unobserve(entry.key, reRun));\n}\nfunction getValue(reactiveHydro) {\n    const [resolvedValue] = resolveObject(Reflect.get(reactiveHydro, keysSymbol.description));\n    return resolvedValue;\n}\nlet calledOnRender = false;\nfunction onRender(fn, elem, ...args) {\n    calledOnRender = true;\n    onRenderMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\nlet calledOnCleanup = false;\nfunction onCleanup(fn, elem, ...args) {\n    calledOnCleanup = true;\n    onCleanupMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\n// Core of the library\nfunction generateProxy(obj) {\n    const handlers = Symbol(\"handlers\"); // For observer pattern\n    const boundFunctions = new WeakMap();\n    const proxy = new Proxy(obj ?? {}, {\n        // If receiver is a getter, then it is the object on which the search first started for the property|key -> Proxy\n        set(target, key, val, receiver) {\n            if (trackDeps) {\n                trackProxies.add(receiver);\n                if (trackMap.has(receiver)) {\n                    trackMap.get(receiver).add(key);\n                }\n                else {\n                    trackMap.set(receiver, new Set([key]));\n                }\n            }\n            let returnSet = true;\n            let oldVal = Reflect.get(target, key, receiver);\n            if (oldVal === val)\n                return returnSet;\n            // Reset Path - mostly GC\n            if (val === null) {\n                // Remove entry from reactitivyMap underlying Map\n                if (reactivityMap.has(receiver)) {\n                    const key2NodeMap = reactivityMap.get(receiver);\n                    key2NodeMap.delete(String(key));\n                    if (key2NodeMap.size === 0) {\n                        reactivityMap.delete(receiver);\n                    }\n                }\n                // Inform the Observers about null change and unobserve\n                const observer = Reflect.get(target, handlers, receiver);\n                if (observer.has(key)) {\n                    let set = observer.get(key);\n                    for (const handler of set) {\n                        handler(null, oldVal);\n                    }\n                    set.clear();\n                    receiver.unobserve(key);\n                }\n                // If oldVal is a Proxy - clean it\n                if (isObject(oldVal) && isProxy(oldVal)) {\n                    reactivityMap.delete(oldVal);\n                    if (bindMap.has(oldVal)) {\n                        bindMap.get(oldVal).forEach(removeElement);\n                        bindMap.delete(oldVal);\n                    }\n                }\n                else {\n                    if (bindMap.has(receiver)) {\n                        bindMap.get(receiver).forEach(removeElement);\n                        bindMap.delete(receiver);\n                    }\n                }\n                // Remove item from array\n                /* c8 ignore next 4 */\n                if (!internReset && Array.isArray(receiver)) {\n                    receiver.splice(Number(key), 1);\n                    return returnSet;\n                }\n                return Reflect.deleteProperty(receiver, key);\n            }\n            // Set the value\n            if (isPromise(val)) {\n                const promise = val;\n                promise\n                    .then((value) => {\n                    // No Reflect in order to trigger the Getter\n                    receiver[key] = value;\n                })\n                    .catch((e) => {\n                    console.error(e);\n                    receiver[key] = null;\n                });\n                returnSet = Reflect.set(target, key, val, receiver);\n                return returnSet;\n            }\n            else if (isNode(val)) {\n                returnSet = Reflect.set(target, key, val, receiver);\n            }\n            else if (isObject(val) && !isProxy(val)) {\n                returnSet = Reflect.set(target, key, generateProxy(val), receiver);\n                // Recursively set properties to Proxys too\n                for (const [subKey, subVal] of Object.entries(val)) {\n                    if (isObject(subVal) && !isProxy(subVal)) {\n                        Reflect.set(val, subKey, generateProxy(subVal));\n                    }\n                }\n            }\n            else {\n                if (!reuseElements &&\n                    Array.isArray(receiver) &&\n                    receiver.includes(oldVal) &&\n                    receiver.includes(val) &&\n                    /* c8 ignore start */\n                    bindMap.has(val)) {\n                    const [elem] = bindMap.get(val);\n                    if (lastSwapElem !== elem) {\n                        const [oldElem] = bindMap.get(oldVal);\n                        lastSwapElem = oldElem;\n                        const prevElem = elem.previousSibling;\n                        const prevOldElem = oldElem.previousSibling;\n                        // Move it in the array too without triggering the proxy set\n                        const index = receiver.findIndex((i) => i === val);\n                        receiver.splice(Number(key), 1, val);\n                        receiver.splice(index, 1, oldVal);\n                        prevElem.after(oldElem);\n                        prevOldElem.after(elem);\n                    }\n                    return true;\n                }\n                else {\n                    /* c8 ignore end */\n                    returnSet = Reflect.set(target, key, val, receiver);\n                }\n            }\n            const newVal = Reflect.get(target, key, receiver);\n            // Check if DOM needs to be updated\n            // oldVal can be Proxy value too\n            if (reactivityMap.has(oldVal)) {\n                checkReactivityMap(oldVal, key, newVal, oldVal);\n            }\n            else if (reactivityMap.has(receiver)) {\n                checkReactivityMap(receiver, key, newVal, oldVal);\n            }\n            // current val (before setting) is a proxy - take over its keyToNodeMap\n            if (isObject(val) && isProxy(val)) {\n                if (reactivityMap.has(oldVal)) {\n                    // Store old reactivityMap if it is a swap operation\n                    reuseElements && tmpSwap.set(oldVal, reactivityMap.get(oldVal));\n                    if (tmpSwap.has(val)) {\n                        reactivityMap.set(oldVal, tmpSwap.get(val));\n                        tmpSwap.delete(val);\n                    }\n                    else {\n                        reactivityMap.set(oldVal, reactivityMap.get(val));\n                    }\n                }\n            }\n            // Inform the Observers\n            if (returnSet) {\n                Reflect.get(target, handlers, receiver)\n                    .get(key)\n                    ?.forEach((handler) => handler(newVal, oldVal));\n            }\n            // If oldVal is a Proxy - clean it\n            !reuseElements && oldVal && cleanProxy(oldVal);\n            return returnSet;\n        },\n        // fix proxy bugs, e.g Map\n        get(target, prop, receiver) {\n            if (trackDeps) {\n                trackProxies.add(receiver);\n                if (trackMap.has(receiver)) {\n                    trackMap.get(receiver).add(prop);\n                }\n                else {\n                    trackMap.set(receiver, new Set([prop]));\n                }\n            }\n            const value = Reflect.get(target, prop, receiver);\n            if (!isFunction(value)) {\n                return value;\n            }\n            if (!boundFunctions.has(value)) {\n                boundFunctions.set(value, value.bind(target));\n            }\n            return boundFunctions.get(value);\n        },\n    });\n    Reflect.defineProperty(proxy, \"isProxy\" /* Placeholder.isProxy */, {\n        value: true,\n    });\n    Reflect.defineProperty(proxy, \"asyncUpdate\" /* Placeholder.asyncUpdate */, {\n        value: globalSchedule,\n        writable: true,\n    });\n    Reflect.defineProperty(proxy, handlers, {\n        value: new Map(),\n    });\n    Reflect.defineProperty(proxy, \"observe\" /* Placeholder.observe */, {\n        value(key, handler) {\n            const map = Reflect.get(proxy, handlers);\n            if (map.has(key)) {\n                map.get(key).add(handler);\n            }\n            else {\n                map.set(key, new Set([handler]));\n            }\n        },\n        configurable: true,\n    });\n    Reflect.defineProperty(proxy, \"getObservers\" /* Placeholder.getObservers */, {\n        value() {\n            return Reflect.get(proxy, handlers);\n        },\n        configurable: true,\n    });\n    Reflect.defineProperty(proxy, \"unobserve\" /* Placeholder.unobserve */, {\n        value(key, handler) {\n            const map = Reflect.get(proxy, handlers);\n            if (key) {\n                if (map.has(key)) {\n                    if (handler == null) {\n                        map.delete(key);\n                    }\n                    else {\n                        const set = map.get(key);\n                        if (set?.has(handler)) {\n                            set.delete(handler);\n                        }\n                    }\n                }\n                /* c8 ignore next 3 */\n            }\n            else {\n                map.clear();\n            }\n        },\n        configurable: true,\n    });\n    if (!obj)\n        Reflect.defineProperty(proxy, _boundFunctions, {\n            value: boundFunctions,\n        });\n    return proxy;\n}\nfunction cleanProxy(proxy) {\n    if (isObject(proxy) && isProxy(proxy)) {\n        reactivityMap.delete(proxy);\n        /* c8 ignore next 4 */\n        if (bindMap.has(proxy)) {\n            bindMap.get(proxy).forEach(removeElement);\n            bindMap.delete(proxy);\n        }\n    }\n}\nfunction checkReactivityMap(obj, key, val, oldVal) {\n    const keyToNodeMap = reactivityMap.get(obj);\n    const nodeToChangeMap = keyToNodeMap.get(String(key));\n    if (nodeToChangeMap) {\n        /* c8 ignore next 5 */\n        if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n            schedule(updateDOM, nodeToChangeMap, val, oldVal);\n        }\n        else {\n            updateDOM(nodeToChangeMap, val, oldVal);\n        }\n    }\n    if (isObject(val)) {\n        for (const [subKey, subVal] of Object.entries(val)) {\n            const subOldVal = (isObject(oldVal) && Reflect.get(oldVal, subKey)) || oldVal;\n            const nodeToChangeMap = keyToNodeMap.get(subKey);\n            if (nodeToChangeMap) {\n                /* c8 ignore next 5 */\n                if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n                    schedule(updateDOM, nodeToChangeMap, subVal, subOldVal);\n                }\n                else {\n                    updateDOM(nodeToChangeMap, subVal, subOldVal);\n                }\n            }\n        }\n    }\n}\nfunction updateDOM(nodeToChangeMap, val, oldVal) {\n    nodeToChangeMap.forEach((entry) => {\n        // Circular reference in order to keep Memory low\n        if (isNode(entry)) {\n            /* c8 ignore next 5 */\n            if (!entry.isConnected) {\n                const tmpChange = nodeToChangeMap.get(entry);\n                nodeToChangeMap.delete(entry);\n                nodeToChangeMap.delete(tmpChange);\n            }\n            return; // Continue in forEach\n        }\n        // For each change of the node update either attribute or textContent\n        for (const change of entry) {\n            const node = nodeToChangeMap.get(entry);\n            const [start, end, key] = change;\n            let useStartEnd = false;\n            if (isNode(val)) {\n                replaceElement(val, node);\n                if (val !== node) {\n                    nodeToChangeMap.delete(node);\n                    if (!isDocumentFragment(val)) {\n                        nodeToChangeMap.set(val, entry);\n                        nodeToChangeMap.set(entry, val);\n                    }\n                }\n            }\n            else if (isTextNode(node)) {\n                useStartEnd = true;\n                let text = node.nodeValue;\n                node.nodeValue =\n                    text.substring(0, start) + String(val) + text.substring(end);\n            }\n            else {\n                if (key === \"two-way\" /* Placeholder.twoWay */) {\n                    if (node instanceof HTMLInputElement &&\n                        node.type === \"radio\" /* Placeholder.radio */) {\n                        node.checked = Array.isArray(val)\n                            ? val.includes(node.name)\n                            : String(val) === node.value;\n                    }\n                    else if (node instanceof HTMLInputElement &&\n                        node.type === \"checkbox\" /* Placeholder.checkbox */) {\n                        node.checked = val;\n                    }\n                    else if (node instanceof HTMLTextAreaElement ||\n                        node instanceof HTMLSelectElement ||\n                        node instanceof HTMLInputElement) {\n                        node.value = String(val);\n                    }\n                }\n                else if (isFunction(val) || isEventObject(val)) {\n                    const eventName = key.replace(onEventRegex, \"\");\n                    node.removeEventListener(eventName, isFunction(oldVal) ? oldVal : oldVal.event);\n                    addEventListener(node, eventName, val);\n                }\n                else if (isObject(val)) {\n                    for (const [subKey, subVal] of Object.entries(val)) {\n                        if (isFunction(subVal) || isEventObject(subVal)) {\n                            const eventName = subKey.replace(onEventRegex, \"\");\n                            node.removeEventListener(eventName, isFunction(oldVal[subKey])\n                                ? oldVal[subKey]\n                                : oldVal[subKey].event);\n                            addEventListener(node, eventName, subVal);\n                        }\n                        else {\n                            setAttribute(node, subKey, subVal);\n                        }\n                    }\n                }\n                else {\n                    useStartEnd = true;\n                    let attr = node.getAttribute(key);\n                    if (attr) {\n                        attr = attr.substring(0, start) + String(val) + attr.substring(end);\n                        setAttribute(node, key, attr === String(val) ? val : attr);\n                    }\n                    else {\n                        setAttribute(node, key, val);\n                    }\n                }\n            }\n            if (useStartEnd) {\n                // Update end\n                change[1] = start + String(val).length;\n                // Because we updated the end, we also have to update the start and end for every other reactive change in the node, for the same key\n                if (allNodeChanges.has(node)) {\n                    let passedNode = false;\n                    for (const nodeChange of allNodeChanges.get(node)) {\n                        if (nodeChange === change) {\n                            passedNode = true;\n                            continue;\n                        }\n                        if (passedNode && (isTextNode(node) || key === nodeChange[2])) {\n                            const difference = String(oldVal).length - String(val).length;\n                            nodeChange[0] -= difference;\n                            nodeChange[1] -= difference;\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\nfunction view(root, data, renderFunction) {\n    viewElements = true;\n    const rootElem = $(root);\n    const elements = getValue(data).map(renderFunction);\n    rootElem.append(...elements);\n    for (const elem of elements)\n        runLifecyle(elem, onRenderMap);\n    if (rootElem.hasChildNodes())\n        setReactivity(rootElem);\n    onCleanup(unset, rootElem, data);\n    viewElements = false;\n    observe(data, (newData, oldData) => {\n        /* c8 ignore start */\n        viewElements = true;\n        // Reset or re-use\n        if (!newData?.length ||\n            (!reuseElements && newData?.length === oldData?.length)) {\n            rootElem.textContent = \"\";\n        }\n        else if (reuseElements) {\n            for (let i = 0; i < oldData?.length && newData?.length; i++) {\n                oldData[i].id = newData[i].id;\n                oldData[i].label = newData[i].label;\n                newData[i] = oldData[i];\n            }\n        }\n        // Add to existing\n        if (oldData?.length &&\n            newData?.length > oldData?.length &&\n            newData[0] === oldData[0]) {\n            const length = oldData.length;\n            const slicedData = newData.slice(length);\n            const newElements = slicedData.map((item, i) => renderFunction(item, i + length));\n            rootElem.append(...newElements);\n            for (const elem of newElements)\n                runLifecyle(elem, onRenderMap);\n        }\n        // Add new\n        else if (oldData?.length === 0 || (!reuseElements && newData?.length)) {\n            if (!reuseElements && oldData?.length && rootElem.hasChildNodes()) {\n                rootElem.textContent = \"\";\n            }\n            const elements = newData.map(renderFunction);\n            rootElem.append(...elements);\n            for (const elem of elements)\n                runLifecyle(elem, onRenderMap);\n        }\n        if (rootElem.hasChildNodes())\n            setReactivity(rootElem);\n        viewElements = false;\n        /* c8 ignore end */\n    });\n}\nconst hydro = generateProxy();\nconst $ = document.querySelector.bind(document);\nconst $$ = document.querySelectorAll.bind(document);\nconst internals = {\n    compare,\n};\nexport { render, html, h, hydro, setGlobalSchedule, setReuseElements, setInsertDiffing, setShouldSetReactivity, reactive, unset, setAsyncUpdate, unobserve, observe, ternary, emit, watchEffect, internals, getValue, onRender, onCleanup, setReactivity, $, $$, view, };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}